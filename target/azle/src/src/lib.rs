
        
        // This code is automatically generated by Azle

        // #![allow(dead_code)]
        // #![allow(non_camel_case_types)]
        // #![allow(non_snake_case)]
        // #![allow(unused_imports)]
        // #![allow(unused_variables)]

        #![allow(warnings, unused)]

        use std::str::FromStr;
        use azle_js_value_derive::{
            AzleIntoJsValue,
            AzleTryFromJsValue
        };

        // TODO old safe working way
        // TODO I want to make sure I am doing this safely, but I can't do async code from within a with block
        // thread_local! {
        //     static BOA_CONTEXT: std::cell::RefCell<boa_engine::Context> = std::cell::RefCell::new(boa_engine::Context::default());
        // }

        // TODO new unsafe working way
        // TODO we are treading in dangerous territory now
        // TODO study this: https://mmapped.blog/posts/01-effective-rust-canisters.html
        // TODO try to get help from those on the forum
        // TODO it might be fine since we only ever obtain one mutable reference per query/update call
        // TODO we do not allow the user to obtain multiple mutable references, we only have one
        // TODO as long as we enforce that, we might be fine
        static mut BOA_CONTEXT_OPTION: Option<boa_engine::Context> = None;

        fn custom_getrandom(_buf: &mut [u8]) -> Result<(), getrandom::Error> { Ok(()) }

        getrandom::register_custom_getrandom!(custom_getrandom);

        static MAIN_JS: &'static str = r#"
        // TODO we should centralize/standardize where we add global variables to the JS, we are doing this in multiple places (i.e. the exports variable is not here, found in init/post_upgrade)
        globalThis.console = {
            ...globalThis.console,
            log: (...args) => {
                ic.print(...args);
            }
        };

        
        globalThis.ic.canisters = {
            
        };
    

        
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.totalSupply = exports.name = exports.ticker = exports.balance = exports.transfer = exports.initializeSupply = exports.Principal = void 0;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i1 = 1; i1 < arguments.length; i1++){
        var source = arguments[i1] != null ? arguments[i1] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    })
;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    }
;
var __reExport = (target, module2, copyDefault, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default")) __defProp(target, key, {
            get: ()=>module2[key]
            ,
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toESM = (module2, isNodeMode)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? {
        get: ()=>module2.default
        ,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
    "node_modules/js-sha256/src/sha256.js" (exports1, module) {
        (function() {
            
            var ERROR = "input is invalid type";
            var WINDOW = typeof window === "object";
            var root = WINDOW ? window : {};
            if (root.JS_SHA256_NO_WINDOW) {
                WINDOW = false;
            }
            var WEB_WORKER = !WINDOW && typeof self === "object";
            var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
            if (NODE_JS) {
                root = global;
            } else if (WEB_WORKER) {
                root = self;
            }
            var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
            var AMD = typeof define === "function" && define.amd;
            var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
            var HEX_CHARS = "0123456789abcdef".split("");
            var EXTRA = [
                -2147483648,
                8388608,
                32768,
                128
            ];
            var SHIFT = [
                24,
                16,
                8,
                0
            ];
            var K = [
                1116352408,
                1899447441,
                3049323471,
                3921009573,
                961987163,
                1508970993,
                2453635748,
                2870763221,
                3624381080,
                310598401,
                607225278,
                1426881987,
                1925078388,
                2162078206,
                2614888103,
                3248222580,
                3835390401,
                4022224774,
                264347078,
                604807628,
                770255983,
                1249150122,
                1555081692,
                1996064986,
                2554220882,
                2821834349,
                2952996808,
                3210313671,
                3336571891,
                3584528711,
                113926993,
                338241895,
                666307205,
                773529912,
                1294757372,
                1396182291,
                1695183700,
                1986661051,
                2177026350,
                2456956037,
                2730485921,
                2820302411,
                3259730800,
                3345764771,
                3516065817,
                3600352804,
                4094571909,
                275423344,
                430227734,
                506948616,
                659060556,
                883997877,
                958139571,
                1322822218,
                1537002063,
                1747873779,
                1955562222,
                2024104815,
                2227730452,
                2361852424,
                2428436474,
                2756734187,
                3204031479,
                3329325298
            ];
            var OUTPUT_TYPES = [
                "hex",
                "array",
                "digest",
                "arrayBuffer"
            ];
            var blocks = [];
            if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
                Array.isArray = function(obj) {
                    return Object.prototype.toString.call(obj) === "[object Array]";
                };
            }
            if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
                ArrayBuffer.isView = function(obj) {
                    return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
                };
            }
            var createOutputMethod = function(outputType, is2242) {
                return function(message) {
                    return new Sha256(is2242, true).update(message)[outputType]();
                };
            };
            var createMethod = function(is2242) {
                var method2 = createOutputMethod("hex", is2242);
                if (NODE_JS) {
                    method2 = nodeWrap(method2, is2242);
                }
                method2.create = function() {
                    return new Sha256(is2242);
                };
                method2.update = function(message) {
                    return method2.create().update(message);
                };
                for(var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2){
                    var type = OUTPUT_TYPES[i2];
                    method2[type] = createOutputMethod(type, is2242);
                }
                return method2;
            };
            var nodeWrap = function(method, is224) {
                var crypto = eval("require('crypto')");
                var Buffer = eval("require('buffer').Buffer");
                var algorithm = is224 ? "sha224" : "sha256";
                var nodeMethod = function(message) {
                    if (typeof message === "string") {
                        return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
                    } else {
                        if (message === null || message === void 0) {
                            throw new Error(ERROR);
                        } else if (message.constructor === ArrayBuffer) {
                            message = new Uint8Array(message);
                        }
                    }
                    if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
                        return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
                    } else {
                        return method(message);
                    }
                };
                return nodeMethod;
            };
            var createHmacOutputMethod = function(outputType, is2242) {
                return function(key, message) {
                    return new HmacSha256(key, is2242, true).update(message)[outputType]();
                };
            };
            var createHmacMethod = function(is2242) {
                var method2 = createHmacOutputMethod("hex", is2242);
                method2.create = function(key) {
                    return new HmacSha256(key, is2242);
                };
                method2.update = function(key, message) {
                    return method2.create(key).update(message);
                };
                for(var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3){
                    var type = OUTPUT_TYPES[i3];
                    method2[type] = createHmacOutputMethod(type, is2242);
                }
                return method2;
            };
            function Sha256(is2242, sharedMemory) {
                if (sharedMemory) {
                    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    this.blocks = blocks;
                } else {
                    this.blocks = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ];
                }
                if (is2242) {
                    this.h0 = 3238371032;
                    this.h1 = 914150663;
                    this.h2 = 812702999;
                    this.h3 = 4144912697;
                    this.h4 = 4290775857;
                    this.h5 = 1750603025;
                    this.h6 = 1694076839;
                    this.h7 = 3204075428;
                } else {
                    this.h0 = 1779033703;
                    this.h1 = 3144134277;
                    this.h2 = 1013904242;
                    this.h3 = 2773480762;
                    this.h4 = 1359893119;
                    this.h5 = 2600822924;
                    this.h6 = 528734635;
                    this.h7 = 1541459225;
                }
                this.block = this.start = this.bytes = this.hBytes = 0;
                this.finalized = this.hashed = false;
                this.first = true;
                this.is224 = is2242;
            }
            Sha256.prototype.update = function(message) {
                if (this.finalized) {
                    return;
                }
                var notString, type = typeof message;
                if (type !== "string") {
                    if (type === "object") {
                        if (message === null) {
                            throw new Error(ERROR);
                        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                            message = new Uint8Array(message);
                        } else if (!Array.isArray(message)) {
                            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                                throw new Error(ERROR);
                            }
                        }
                    } else {
                        throw new Error(ERROR);
                    }
                    notString = true;
                }
                var code, index = 0, i4, length = message.length, blocks2 = this.blocks;
                while(index < length){
                    if (this.hashed) {
                        this.hashed = false;
                        blocks2[0] = this.block;
                        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                    }
                    if (notString) {
                        for(i4 = this.start; index < length && i4 < 64; ++index){
                            blocks2[i4 >> 2] |= message[index] << SHIFT[(i4++) & 3];
                        }
                    } else {
                        for(i4 = this.start; index < length && i4 < 64; ++index){
                            code = message.charCodeAt(index);
                            if (code < 128) {
                                blocks2[i4 >> 2] |= code << SHIFT[(i4++) & 3];
                            } else if (code < 2048) {
                                blocks2[i4 >> 2] |= (192 | code >> 6) << SHIFT[(i4++) & 3];
                                blocks2[i4 >> 2] |= (128 | code & 63) << SHIFT[(i4++) & 3];
                            } else if (code < 55296 || code >= 57344) {
                                blocks2[i4 >> 2] |= (224 | code >> 12) << SHIFT[(i4++) & 3];
                                blocks2[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[(i4++) & 3];
                                blocks2[i4 >> 2] |= (128 | code & 63) << SHIFT[(i4++) & 3];
                            } else {
                                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                                blocks2[i4 >> 2] |= (240 | code >> 18) << SHIFT[(i4++) & 3];
                                blocks2[i4 >> 2] |= (128 | code >> 12 & 63) << SHIFT[(i4++) & 3];
                                blocks2[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[(i4++) & 3];
                                blocks2[i4 >> 2] |= (128 | code & 63) << SHIFT[(i4++) & 3];
                            }
                        }
                    }
                    this.lastByteIndex = i4;
                    this.bytes += i4 - this.start;
                    if (i4 >= 64) {
                        this.block = blocks2[16];
                        this.start = i4 - 64;
                        this.hash();
                        this.hashed = true;
                    } else {
                        this.start = i4;
                    }
                }
                if (this.bytes > 4294967295) {
                    this.hBytes += this.bytes / 4294967296 << 0;
                    this.bytes = this.bytes % 4294967296;
                }
                return this;
            };
            Sha256.prototype.finalize = function() {
                if (this.finalized) {
                    return;
                }
                this.finalized = true;
                var blocks2 = this.blocks, i5 = this.lastByteIndex;
                blocks2[16] = this.block;
                blocks2[i5 >> 2] |= EXTRA[i5 & 3];
                this.block = blocks2[16];
                if (i5 >= 56) {
                    if (!this.hashed) {
                        this.hash();
                    }
                    blocks2[0] = this.block;
                    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                }
                blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
                blocks2[15] = this.bytes << 3;
                this.hash();
            };
            Sha256.prototype.hash = function() {
                var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
                for(j = 16; j < 64; ++j){
                    t1 = blocks2[j - 15];
                    s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
                    t1 = blocks2[j - 2];
                    s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
                    blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
                }
                bc = b & c;
                for(j = 0; j < 64; j += 4){
                    if (this.first) {
                        if (this.is224) {
                            ab = 300032;
                            t1 = blocks2[0] - 1413257819;
                            h = t1 - 150054599 << 0;
                            d = t1 + 24177077 << 0;
                        } else {
                            ab = 704751109;
                            t1 = blocks2[0] - 210244248;
                            h = t1 - 1521486534 << 0;
                            d = t1 + 143694565 << 0;
                        }
                        this.first = false;
                    } else {
                        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
                        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
                        ab = a & b;
                        maj = ab ^ a & c ^ bc;
                        ch = e & f ^ ~e & g;
                        t1 = h + s1 + ch + K[j] + blocks2[j];
                        t2 = s0 + maj;
                        h = d + t1 << 0;
                        d = t1 + t2 << 0;
                    }
                    s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
                    s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
                    da = d & a;
                    maj = da ^ d & b ^ ab;
                    ch = h & e ^ ~h & f;
                    t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
                    t2 = s0 + maj;
                    g = c + t1 << 0;
                    c = t1 + t2 << 0;
                    s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
                    s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
                    cd = c & d;
                    maj = cd ^ c & a ^ da;
                    ch = g & h ^ ~g & e;
                    t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
                    t2 = s0 + maj;
                    f = b + t1 << 0;
                    b = t1 + t2 << 0;
                    s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
                    s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
                    bc = b & c;
                    maj = bc ^ b & d ^ cd;
                    ch = f & g ^ ~f & h;
                    t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
                    t2 = s0 + maj;
                    e = a + t1 << 0;
                    a = t1 + t2 << 0;
                }
                this.h0 = this.h0 + a << 0;
                this.h1 = this.h1 + b << 0;
                this.h2 = this.h2 + c << 0;
                this.h3 = this.h3 + d << 0;
                this.h4 = this.h4 + e << 0;
                this.h5 = this.h5 + f << 0;
                this.h6 = this.h6 + g << 0;
                this.h7 = this.h7 + h << 0;
            };
            Sha256.prototype.hex = function() {
                this.finalize();
                var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
                var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
                if (!this.is224) {
                    hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
                }
                return hex;
            };
            Sha256.prototype.toString = Sha256.prototype.hex;
            Sha256.prototype.digest = function() {
                this.finalize();
                var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
                var arr = [
                    h0 >> 24 & 255,
                    h0 >> 16 & 255,
                    h0 >> 8 & 255,
                    h0 & 255,
                    h1 >> 24 & 255,
                    h1 >> 16 & 255,
                    h1 >> 8 & 255,
                    h1 & 255,
                    h2 >> 24 & 255,
                    h2 >> 16 & 255,
                    h2 >> 8 & 255,
                    h2 & 255,
                    h3 >> 24 & 255,
                    h3 >> 16 & 255,
                    h3 >> 8 & 255,
                    h3 & 255,
                    h4 >> 24 & 255,
                    h4 >> 16 & 255,
                    h4 >> 8 & 255,
                    h4 & 255,
                    h5 >> 24 & 255,
                    h5 >> 16 & 255,
                    h5 >> 8 & 255,
                    h5 & 255,
                    h6 >> 24 & 255,
                    h6 >> 16 & 255,
                    h6 >> 8 & 255,
                    h6 & 255
                ];
                if (!this.is224) {
                    arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
                }
                return arr;
            };
            Sha256.prototype.array = Sha256.prototype.digest;
            Sha256.prototype.arrayBuffer = function() {
                this.finalize();
                var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
                var dataView = new DataView(buffer);
                dataView.setUint32(0, this.h0);
                dataView.setUint32(4, this.h1);
                dataView.setUint32(8, this.h2);
                dataView.setUint32(12, this.h3);
                dataView.setUint32(16, this.h4);
                dataView.setUint32(20, this.h5);
                dataView.setUint32(24, this.h6);
                if (!this.is224) {
                    dataView.setUint32(28, this.h7);
                }
                return buffer;
            };
            function HmacSha256(key, is2242, sharedMemory) {
                var i6, type = typeof key;
                if (type === "string") {
                    var bytes = [], length = key.length, index = 0, code;
                    for(i6 = 0; i6 < length; ++i6){
                        code = key.charCodeAt(i6);
                        if (code < 128) {
                            bytes[index++] = code;
                        } else if (code < 2048) {
                            bytes[index++] = 192 | code >> 6;
                            bytes[index++] = 128 | code & 63;
                        } else if (code < 55296 || code >= 57344) {
                            bytes[index++] = 224 | code >> 12;
                            bytes[index++] = 128 | code >> 6 & 63;
                            bytes[index++] = 128 | code & 63;
                        } else {
                            code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i6) & 1023);
                            bytes[index++] = 240 | code >> 18;
                            bytes[index++] = 128 | code >> 12 & 63;
                            bytes[index++] = 128 | code >> 6 & 63;
                            bytes[index++] = 128 | code & 63;
                        }
                    }
                    key = bytes;
                } else {
                    if (type === "object") {
                        if (key === null) {
                            throw new Error(ERROR);
                        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                            key = new Uint8Array(key);
                        } else if (!Array.isArray(key)) {
                            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                                throw new Error(ERROR);
                            }
                        }
                    } else {
                        throw new Error(ERROR);
                    }
                }
                if (key.length > 64) {
                    key = new Sha256(is2242, true).update(key).array();
                }
                var oKeyPad = [], iKeyPad = [];
                for(i6 = 0; i6 < 64; ++i6){
                    var b = key[i6] || 0;
                    oKeyPad[i6] = 92 ^ b;
                    iKeyPad[i6] = 54 ^ b;
                }
                Sha256.call(this, is2242, sharedMemory);
                this.update(iKeyPad);
                this.oKeyPad = oKeyPad;
                this.inner = true;
                this.sharedMemory = sharedMemory;
            }
            HmacSha256.prototype = new Sha256();
            HmacSha256.prototype.finalize = function() {
                Sha256.prototype.finalize.call(this);
                if (this.inner) {
                    this.inner = false;
                    var innerHash = this.array();
                    Sha256.call(this, this.is224, this.sharedMemory);
                    this.update(this.oKeyPad);
                    this.update(innerHash);
                    Sha256.prototype.finalize.call(this);
                }
            };
            var exports = createMethod();
            exports.sha256 = exports;
            exports.sha224 = createMethod(true);
            exports.sha256.hmac = createHmacMethod();
            exports.sha224.hmac = createHmacMethod(true);
            if (COMMON_JS) {
                module.exports = exports;
            } else {
                root.sha256 = exports.sha256;
                root.sha224 = exports.sha224;
                if (AMD) {
                    define(function() {
                        return exports;
                    });
                }
            }
        })();
    }
});
// node_modules/@dfinity/principal/lib/esm/utils/base32.js
var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
var lookupTable = /* @__PURE__ */ Object.create(null);
for(let i = 0; i < alphabet.length; i++){
    lookupTable[alphabet[i]] = i;
}
lookupTable["0"] = lookupTable.o;
lookupTable["1"] = lookupTable.i;
function encode(input) {
    let skip = 0;
    let bits = 0;
    let output = "";
    function encodeByte(byte) {
        if (skip < 0) {
            bits |= byte >> -skip;
        } else {
            bits = byte << skip & 248;
        }
        if (skip > 3) {
            skip -= 8;
            return 1;
        }
        if (skip < 4) {
            output += alphabet[bits >> 3];
            skip += 5;
        }
        return 0;
    }
    for(let i7 = 0; i7 < input.length;){
        i7 += encodeByte(input[i7]);
    }
    return output + (skip < 0 ? alphabet[bits >> 3] : "");
}
function decode(input) {
    let skip = 0;
    let byte = 0;
    const output = new Uint8Array(input.length * 4 / 3 | 0);
    let o = 0;
    function decodeChar(char) {
        let val = lookupTable[char.toLowerCase()];
        if (val === void 0) {
            throw new Error(`Invalid character: ${JSON.stringify(char)}`);
        }
        val <<= 3;
        byte |= val >>> skip;
        skip += 5;
        if (skip >= 8) {
            output[o++] = byte;
            skip -= 8;
            if (skip > 0) {
                byte = val << 5 - skip & 255;
            } else {
                byte = 0;
            }
        }
    }
    for (const c of input){
        decodeChar(c);
    }
    return output.slice(0, o);
}
// node_modules/@dfinity/principal/lib/esm/utils/getCrc.js
var lookUpTable = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
]);
function getCrc32(buf) {
    const b = new Uint8Array(buf);
    let crc = -1;
    for(let i8 = 0; i8 < b.length; i8++){
        const byte = b[i8];
        const t = (byte ^ crc) & 255;
        crc = lookUpTable[t] ^ crc >>> 8;
    }
    return (crc ^ -1) >>> 0;
}
// node_modules/@dfinity/principal/lib/esm/utils/sha224.js
var import_js_sha256 = __toESM(require_sha256());
function sha224(data) {
    const shaObj = import_js_sha256.sha224.create();
    shaObj.update(data);
    return new Uint8Array(shaObj.array());
}
// node_modules/@dfinity/principal/lib/esm/index.js
var SELF_AUTHENTICATING_SUFFIX = 2;
var ANONYMOUS_SUFFIX = 4;
var fromHexString = (hexString)=>{
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map((byte)=>parseInt(byte, 16)
    ));
};
var toHexString = (bytes)=>bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, "0")
    , "")
;
var Principal = class {
    static anonymous() {
        return new this(new Uint8Array([
            ANONYMOUS_SUFFIX
        ]));
    }
    static selfAuthenticating(publicKey) {
        const sha = sha224(publicKey);
        return new this(new Uint8Array([
            ...sha,
            SELF_AUTHENTICATING_SUFFIX
        ]));
    }
    static from(other) {
        if (typeof other === "string") {
            return Principal.fromText(other);
        } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
            return new Principal(other._arr);
        }
        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
    }
    static fromHex(hex) {
        return new this(fromHexString(hex));
    }
    static fromText(text) {
        const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
        let arr = decode(canisterIdNoDash);
        arr = arr.slice(4, arr.length);
        const principal = new this(arr);
        if (principal.toText() !== text) {
            throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${text}" may not be a valid Principal ID).`);
        }
        return principal;
    }
    static fromUint8Array(arr) {
        return new this(arr);
    }
    isAnonymous() {
        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
    }
    toUint8Array() {
        return this._arr;
    }
    toHex() {
        return toHexString(this._arr).toUpperCase();
    }
    toText() {
        const checksumArrayBuf = new ArrayBuffer(4);
        const view = new DataView(checksumArrayBuf);
        view.setUint32(0, getCrc32(this._arr));
        const checksum = new Uint8Array(checksumArrayBuf);
        const bytes = Uint8Array.from(this._arr);
        const array = new Uint8Array([
            ...checksum,
            ...bytes
        ]);
        const result = encode(array);
        const matches = result.match(/.{1,5}/g);
        if (!matches) {
            throw new Error();
        }
        return matches.join("-");
    }
    toString() {
        return this.toText();
    }
    constructor(_arr){
        this._arr = _arr;
        this._isPrincipal = true;
    }
};
exports.Principal = Principal;
// src/index.ts
var state = {
    accounts: {},
    totalSupply: 0n,
    ticker: "",
    name: ""
};
function initializeSupply(ticker2, name2, totalSupply2, originalAddress) {
    state = _objectSpread({}, state, {
        accounts: {
            [originalAddress]: {
                address: originalAddress,
                balance: totalSupply2
            }
        },
        ticker: ticker2,
        name: name2,
        totalSupply: totalSupply2
    });
    return true;
}
exports.initializeSupply = initializeSupply;
function transfer(from, to, amount) {
    if (state.accounts[to] === void 0) {
        state.accounts[to] = {
            address: to,
            balance: 0n
        };
    }
    state.accounts[from].balance -= amount;
    state.accounts[to].balance += amount;
    return true;
}
exports.transfer = transfer;
function balance(address) {
    var ref;
    var ref1;
    return (ref1 = (ref = state.accounts[address]) === null || ref === void 0 ? void 0 : ref.balance) !== null && ref1 !== void 0 ? ref1 : 0n;
}
exports.balance = balance;
function ticker() {
    return state.ticker;
}
exports.ticker = ticker;
function name() {
    return state.name;
}
exports.name = name;
function totalSupply() {
    return state.totalSupply;
}
exports.totalSupply = totalSupply;

    "#;

        static PRINCIPAL_JS: &'static str = r#"
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Principal = void 0;
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    })
;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    }
;
var __reExport = (target, module2, copyDefault, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default")) __defProp(target, key, {
            get: ()=>module2[key]
            ,
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toESM = (module2, isNodeMode)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? {
        get: ()=>module2.default
        ,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
    "node_modules/js-sha256/src/sha256.js" (exports1, module) {
        (function() {
            
            var ERROR = "input is invalid type";
            var WINDOW = typeof window === "object";
            var root = WINDOW ? window : {};
            if (root.JS_SHA256_NO_WINDOW) {
                WINDOW = false;
            }
            var WEB_WORKER = !WINDOW && typeof self === "object";
            var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
            if (NODE_JS) {
                root = global;
            } else if (WEB_WORKER) {
                root = self;
            }
            var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
            var AMD = typeof define === "function" && define.amd;
            var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
            var HEX_CHARS = "0123456789abcdef".split("");
            var EXTRA = [
                -2147483648,
                8388608,
                32768,
                128
            ];
            var SHIFT = [
                24,
                16,
                8,
                0
            ];
            var K = [
                1116352408,
                1899447441,
                3049323471,
                3921009573,
                961987163,
                1508970993,
                2453635748,
                2870763221,
                3624381080,
                310598401,
                607225278,
                1426881987,
                1925078388,
                2162078206,
                2614888103,
                3248222580,
                3835390401,
                4022224774,
                264347078,
                604807628,
                770255983,
                1249150122,
                1555081692,
                1996064986,
                2554220882,
                2821834349,
                2952996808,
                3210313671,
                3336571891,
                3584528711,
                113926993,
                338241895,
                666307205,
                773529912,
                1294757372,
                1396182291,
                1695183700,
                1986661051,
                2177026350,
                2456956037,
                2730485921,
                2820302411,
                3259730800,
                3345764771,
                3516065817,
                3600352804,
                4094571909,
                275423344,
                430227734,
                506948616,
                659060556,
                883997877,
                958139571,
                1322822218,
                1537002063,
                1747873779,
                1955562222,
                2024104815,
                2227730452,
                2361852424,
                2428436474,
                2756734187,
                3204031479,
                3329325298
            ];
            var OUTPUT_TYPES = [
                "hex",
                "array",
                "digest",
                "arrayBuffer"
            ];
            var blocks = [];
            if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
                Array.isArray = function(obj) {
                    return Object.prototype.toString.call(obj) === "[object Array]";
                };
            }
            if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
                ArrayBuffer.isView = function(obj) {
                    return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
                };
            }
            var createOutputMethod = function(outputType, is2242) {
                return function(message) {
                    return new Sha256(is2242, true).update(message)[outputType]();
                };
            };
            var createMethod = function(is2242) {
                var method2 = createOutputMethod("hex", is2242);
                if (NODE_JS) {
                    method2 = nodeWrap(method2, is2242);
                }
                method2.create = function() {
                    return new Sha256(is2242);
                };
                method2.update = function(message) {
                    return method2.create().update(message);
                };
                for(var i1 = 0; i1 < OUTPUT_TYPES.length; ++i1){
                    var type = OUTPUT_TYPES[i1];
                    method2[type] = createOutputMethod(type, is2242);
                }
                return method2;
            };
            var nodeWrap = function(method, is224) {
                var crypto = eval("require('crypto')");
                var Buffer = eval("require('buffer').Buffer");
                var algorithm = is224 ? "sha224" : "sha256";
                var nodeMethod = function(message) {
                    if (typeof message === "string") {
                        return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
                    } else {
                        if (message === null || message === void 0) {
                            throw new Error(ERROR);
                        } else if (message.constructor === ArrayBuffer) {
                            message = new Uint8Array(message);
                        }
                    }
                    if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
                        return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
                    } else {
                        return method(message);
                    }
                };
                return nodeMethod;
            };
            var createHmacOutputMethod = function(outputType, is2242) {
                return function(key, message) {
                    return new HmacSha256(key, is2242, true).update(message)[outputType]();
                };
            };
            var createHmacMethod = function(is2242) {
                var method2 = createHmacOutputMethod("hex", is2242);
                method2.create = function(key) {
                    return new HmacSha256(key, is2242);
                };
                method2.update = function(key, message) {
                    return method2.create(key).update(message);
                };
                for(var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2){
                    var type = OUTPUT_TYPES[i2];
                    method2[type] = createHmacOutputMethod(type, is2242);
                }
                return method2;
            };
            function Sha256(is2242, sharedMemory) {
                if (sharedMemory) {
                    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    this.blocks = blocks;
                } else {
                    this.blocks = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ];
                }
                if (is2242) {
                    this.h0 = 3238371032;
                    this.h1 = 914150663;
                    this.h2 = 812702999;
                    this.h3 = 4144912697;
                    this.h4 = 4290775857;
                    this.h5 = 1750603025;
                    this.h6 = 1694076839;
                    this.h7 = 3204075428;
                } else {
                    this.h0 = 1779033703;
                    this.h1 = 3144134277;
                    this.h2 = 1013904242;
                    this.h3 = 2773480762;
                    this.h4 = 1359893119;
                    this.h5 = 2600822924;
                    this.h6 = 528734635;
                    this.h7 = 1541459225;
                }
                this.block = this.start = this.bytes = this.hBytes = 0;
                this.finalized = this.hashed = false;
                this.first = true;
                this.is224 = is2242;
            }
            Sha256.prototype.update = function(message) {
                if (this.finalized) {
                    return;
                }
                var notString, type = typeof message;
                if (type !== "string") {
                    if (type === "object") {
                        if (message === null) {
                            throw new Error(ERROR);
                        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                            message = new Uint8Array(message);
                        } else if (!Array.isArray(message)) {
                            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                                throw new Error(ERROR);
                            }
                        }
                    } else {
                        throw new Error(ERROR);
                    }
                    notString = true;
                }
                var code, index = 0, i3, length = message.length, blocks2 = this.blocks;
                while(index < length){
                    if (this.hashed) {
                        this.hashed = false;
                        blocks2[0] = this.block;
                        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                    }
                    if (notString) {
                        for(i3 = this.start; index < length && i3 < 64; ++index){
                            blocks2[i3 >> 2] |= message[index] << SHIFT[(i3++) & 3];
                        }
                    } else {
                        for(i3 = this.start; index < length && i3 < 64; ++index){
                            code = message.charCodeAt(index);
                            if (code < 128) {
                                blocks2[i3 >> 2] |= code << SHIFT[(i3++) & 3];
                            } else if (code < 2048) {
                                blocks2[i3 >> 2] |= (192 | code >> 6) << SHIFT[(i3++) & 3];
                                blocks2[i3 >> 2] |= (128 | code & 63) << SHIFT[(i3++) & 3];
                            } else if (code < 55296 || code >= 57344) {
                                blocks2[i3 >> 2] |= (224 | code >> 12) << SHIFT[(i3++) & 3];
                                blocks2[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[(i3++) & 3];
                                blocks2[i3 >> 2] |= (128 | code & 63) << SHIFT[(i3++) & 3];
                            } else {
                                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                                blocks2[i3 >> 2] |= (240 | code >> 18) << SHIFT[(i3++) & 3];
                                blocks2[i3 >> 2] |= (128 | code >> 12 & 63) << SHIFT[(i3++) & 3];
                                blocks2[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[(i3++) & 3];
                                blocks2[i3 >> 2] |= (128 | code & 63) << SHIFT[(i3++) & 3];
                            }
                        }
                    }
                    this.lastByteIndex = i3;
                    this.bytes += i3 - this.start;
                    if (i3 >= 64) {
                        this.block = blocks2[16];
                        this.start = i3 - 64;
                        this.hash();
                        this.hashed = true;
                    } else {
                        this.start = i3;
                    }
                }
                if (this.bytes > 4294967295) {
                    this.hBytes += this.bytes / 4294967296 << 0;
                    this.bytes = this.bytes % 4294967296;
                }
                return this;
            };
            Sha256.prototype.finalize = function() {
                if (this.finalized) {
                    return;
                }
                this.finalized = true;
                var blocks2 = this.blocks, i4 = this.lastByteIndex;
                blocks2[16] = this.block;
                blocks2[i4 >> 2] |= EXTRA[i4 & 3];
                this.block = blocks2[16];
                if (i4 >= 56) {
                    if (!this.hashed) {
                        this.hash();
                    }
                    blocks2[0] = this.block;
                    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                }
                blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
                blocks2[15] = this.bytes << 3;
                this.hash();
            };
            Sha256.prototype.hash = function() {
                var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
                for(j = 16; j < 64; ++j){
                    t1 = blocks2[j - 15];
                    s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
                    t1 = blocks2[j - 2];
                    s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
                    blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
                }
                bc = b & c;
                for(j = 0; j < 64; j += 4){
                    if (this.first) {
                        if (this.is224) {
                            ab = 300032;
                            t1 = blocks2[0] - 1413257819;
                            h = t1 - 150054599 << 0;
                            d = t1 + 24177077 << 0;
                        } else {
                            ab = 704751109;
                            t1 = blocks2[0] - 210244248;
                            h = t1 - 1521486534 << 0;
                            d = t1 + 143694565 << 0;
                        }
                        this.first = false;
                    } else {
                        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
                        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
                        ab = a & b;
                        maj = ab ^ a & c ^ bc;
                        ch = e & f ^ ~e & g;
                        t1 = h + s1 + ch + K[j] + blocks2[j];
                        t2 = s0 + maj;
                        h = d + t1 << 0;
                        d = t1 + t2 << 0;
                    }
                    s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
                    s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
                    da = d & a;
                    maj = da ^ d & b ^ ab;
                    ch = h & e ^ ~h & f;
                    t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
                    t2 = s0 + maj;
                    g = c + t1 << 0;
                    c = t1 + t2 << 0;
                    s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
                    s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
                    cd = c & d;
                    maj = cd ^ c & a ^ da;
                    ch = g & h ^ ~g & e;
                    t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
                    t2 = s0 + maj;
                    f = b + t1 << 0;
                    b = t1 + t2 << 0;
                    s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
                    s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
                    bc = b & c;
                    maj = bc ^ b & d ^ cd;
                    ch = f & g ^ ~f & h;
                    t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
                    t2 = s0 + maj;
                    e = a + t1 << 0;
                    a = t1 + t2 << 0;
                }
                this.h0 = this.h0 + a << 0;
                this.h1 = this.h1 + b << 0;
                this.h2 = this.h2 + c << 0;
                this.h3 = this.h3 + d << 0;
                this.h4 = this.h4 + e << 0;
                this.h5 = this.h5 + f << 0;
                this.h6 = this.h6 + g << 0;
                this.h7 = this.h7 + h << 0;
            };
            Sha256.prototype.hex = function() {
                this.finalize();
                var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
                var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
                if (!this.is224) {
                    hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
                }
                return hex;
            };
            Sha256.prototype.toString = Sha256.prototype.hex;
            Sha256.prototype.digest = function() {
                this.finalize();
                var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
                var arr = [
                    h0 >> 24 & 255,
                    h0 >> 16 & 255,
                    h0 >> 8 & 255,
                    h0 & 255,
                    h1 >> 24 & 255,
                    h1 >> 16 & 255,
                    h1 >> 8 & 255,
                    h1 & 255,
                    h2 >> 24 & 255,
                    h2 >> 16 & 255,
                    h2 >> 8 & 255,
                    h2 & 255,
                    h3 >> 24 & 255,
                    h3 >> 16 & 255,
                    h3 >> 8 & 255,
                    h3 & 255,
                    h4 >> 24 & 255,
                    h4 >> 16 & 255,
                    h4 >> 8 & 255,
                    h4 & 255,
                    h5 >> 24 & 255,
                    h5 >> 16 & 255,
                    h5 >> 8 & 255,
                    h5 & 255,
                    h6 >> 24 & 255,
                    h6 >> 16 & 255,
                    h6 >> 8 & 255,
                    h6 & 255
                ];
                if (!this.is224) {
                    arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
                }
                return arr;
            };
            Sha256.prototype.array = Sha256.prototype.digest;
            Sha256.prototype.arrayBuffer = function() {
                this.finalize();
                var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
                var dataView = new DataView(buffer);
                dataView.setUint32(0, this.h0);
                dataView.setUint32(4, this.h1);
                dataView.setUint32(8, this.h2);
                dataView.setUint32(12, this.h3);
                dataView.setUint32(16, this.h4);
                dataView.setUint32(20, this.h5);
                dataView.setUint32(24, this.h6);
                if (!this.is224) {
                    dataView.setUint32(28, this.h7);
                }
                return buffer;
            };
            function HmacSha256(key, is2242, sharedMemory) {
                var i5, type = typeof key;
                if (type === "string") {
                    var bytes = [], length = key.length, index = 0, code;
                    for(i5 = 0; i5 < length; ++i5){
                        code = key.charCodeAt(i5);
                        if (code < 128) {
                            bytes[index++] = code;
                        } else if (code < 2048) {
                            bytes[index++] = 192 | code >> 6;
                            bytes[index++] = 128 | code & 63;
                        } else if (code < 55296 || code >= 57344) {
                            bytes[index++] = 224 | code >> 12;
                            bytes[index++] = 128 | code >> 6 & 63;
                            bytes[index++] = 128 | code & 63;
                        } else {
                            code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i5) & 1023);
                            bytes[index++] = 240 | code >> 18;
                            bytes[index++] = 128 | code >> 12 & 63;
                            bytes[index++] = 128 | code >> 6 & 63;
                            bytes[index++] = 128 | code & 63;
                        }
                    }
                    key = bytes;
                } else {
                    if (type === "object") {
                        if (key === null) {
                            throw new Error(ERROR);
                        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                            key = new Uint8Array(key);
                        } else if (!Array.isArray(key)) {
                            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                                throw new Error(ERROR);
                            }
                        }
                    } else {
                        throw new Error(ERROR);
                    }
                }
                if (key.length > 64) {
                    key = new Sha256(is2242, true).update(key).array();
                }
                var oKeyPad = [], iKeyPad = [];
                for(i5 = 0; i5 < 64; ++i5){
                    var b = key[i5] || 0;
                    oKeyPad[i5] = 92 ^ b;
                    iKeyPad[i5] = 54 ^ b;
                }
                Sha256.call(this, is2242, sharedMemory);
                this.update(iKeyPad);
                this.oKeyPad = oKeyPad;
                this.inner = true;
                this.sharedMemory = sharedMemory;
            }
            HmacSha256.prototype = new Sha256();
            HmacSha256.prototype.finalize = function() {
                Sha256.prototype.finalize.call(this);
                if (this.inner) {
                    this.inner = false;
                    var innerHash = this.array();
                    Sha256.call(this, this.is224, this.sharedMemory);
                    this.update(this.oKeyPad);
                    this.update(innerHash);
                    Sha256.prototype.finalize.call(this);
                }
            };
            var exports = createMethod();
            exports.sha256 = exports;
            exports.sha224 = createMethod(true);
            exports.sha256.hmac = createHmacMethod();
            exports.sha224.hmac = createHmacMethod(true);
            if (COMMON_JS) {
                module.exports = exports;
            } else {
                root.sha256 = exports.sha256;
                root.sha224 = exports.sha224;
                if (AMD) {
                    define(function() {
                        return exports;
                    });
                }
            }
        })();
    }
});
// node_modules/@dfinity/principal/lib/esm/utils/base32.js
var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
var lookupTable = /* @__PURE__ */ Object.create(null);
for(let i = 0; i < alphabet.length; i++){
    lookupTable[alphabet[i]] = i;
}
lookupTable["0"] = lookupTable.o;
lookupTable["1"] = lookupTable.i;
function encode(input) {
    let skip = 0;
    let bits = 0;
    let output = "";
    function encodeByte(byte) {
        if (skip < 0) {
            bits |= byte >> -skip;
        } else {
            bits = byte << skip & 248;
        }
        if (skip > 3) {
            skip -= 8;
            return 1;
        }
        if (skip < 4) {
            output += alphabet[bits >> 3];
            skip += 5;
        }
        return 0;
    }
    for(let i6 = 0; i6 < input.length;){
        i6 += encodeByte(input[i6]);
    }
    return output + (skip < 0 ? alphabet[bits >> 3] : "");
}
function decode(input) {
    let skip = 0;
    let byte = 0;
    const output = new Uint8Array(input.length * 4 / 3 | 0);
    let o = 0;
    function decodeChar(char) {
        let val = lookupTable[char.toLowerCase()];
        if (val === void 0) {
            throw new Error(`Invalid character: ${JSON.stringify(char)}`);
        }
        val <<= 3;
        byte |= val >>> skip;
        skip += 5;
        if (skip >= 8) {
            output[o++] = byte;
            skip -= 8;
            if (skip > 0) {
                byte = val << 5 - skip & 255;
            } else {
                byte = 0;
            }
        }
    }
    for (const c of input){
        decodeChar(c);
    }
    return output.slice(0, o);
}
// node_modules/@dfinity/principal/lib/esm/utils/getCrc.js
var lookUpTable = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
]);
function getCrc32(buf) {
    const b = new Uint8Array(buf);
    let crc = -1;
    for(let i7 = 0; i7 < b.length; i7++){
        const byte = b[i7];
        const t = (byte ^ crc) & 255;
        crc = lookUpTable[t] ^ crc >>> 8;
    }
    return (crc ^ -1) >>> 0;
}
// node_modules/@dfinity/principal/lib/esm/utils/sha224.js
var import_js_sha256 = __toESM(require_sha256());
function sha224(data) {
    const shaObj = import_js_sha256.sha224.create();
    shaObj.update(data);
    return new Uint8Array(shaObj.array());
}
// node_modules/@dfinity/principal/lib/esm/index.js
var SELF_AUTHENTICATING_SUFFIX = 2;
var ANONYMOUS_SUFFIX = 4;
var fromHexString = (hexString)=>{
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map((byte)=>parseInt(byte, 16)
    ));
};
var toHexString = (bytes)=>bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, "0")
    , "")
;
var Principal = class {
    static anonymous() {
        return new this(new Uint8Array([
            ANONYMOUS_SUFFIX
        ]));
    }
    static selfAuthenticating(publicKey) {
        const sha = sha224(publicKey);
        return new this(new Uint8Array([
            ...sha,
            SELF_AUTHENTICATING_SUFFIX
        ]));
    }
    static from(other) {
        if (typeof other === "string") {
            return Principal.fromText(other);
        } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
            return new Principal(other._arr);
        }
        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
    }
    static fromHex(hex) {
        return new this(fromHexString(hex));
    }
    static fromText(text) {
        const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
        let arr = decode(canisterIdNoDash);
        arr = arr.slice(4, arr.length);
        const principal = new this(arr);
        if (principal.toText() !== text) {
            throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${text}" may not be a valid Principal ID).`);
        }
        return principal;
    }
    static fromUint8Array(arr) {
        return new this(arr);
    }
    isAnonymous() {
        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
    }
    toUint8Array() {
        return this._arr;
    }
    toHex() {
        return toHexString(this._arr).toUpperCase();
    }
    toText() {
        const checksumArrayBuf = new ArrayBuffer(4);
        const view = new DataView(checksumArrayBuf);
        view.setUint32(0, getCrc32(this._arr));
        const checksum = new Uint8Array(checksumArrayBuf);
        const bytes = Uint8Array.from(this._arr);
        const array = new Uint8Array([
            ...checksum,
            ...bytes
        ]);
        const result = encode(array);
        const matches = result.match(/.{1,5}/g);
        if (!matches) {
            throw new Error();
        }
        return matches.join("-");
    }
    toString() {
        return this.toText();
    }
    constructor(_arr){
        this._arr = _arr;
        this._isPrincipal = true;
    }
};
exports.Principal = Principal;
"#;
    

        use ic_cdk :: export :: candid :: { self , CandidType , Deserialize } ; use ic_cdk :: api :: call :: CallResult ; struct SERVICE (candid :: Principal) ;

        
            // TODO I think it's debatable whether or not we even need ArgToken
            /// A marker type to match unconstrained callback arguments
            #[derive(Debug, Clone, Copy, PartialEq, Deserialize)]
            pub struct ArgToken;

            impl CandidType for ArgToken {
                fn _ty() -> candid::types::Type {
                    candid::types::Type::Empty
                }

                fn idl_serialize<S: candid::types::Serializer>(&self, _serializer: S) -> Result<(), S::Error> {
                    // We cannot implement serialize, since our type must be `Empty` in order to accept anything.
                    // Attempting to serialize this type is always an error and should be regarded as a compile time error.
                    unimplemented!("Token is not serializable")
                }
            }

            
        

        
        pub trait AzleIntoJsValue {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue;
        }

        // Basic types

        impl AzleIntoJsValue for () {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::JsValue::Null
            }
        }

        impl AzleIntoJsValue for bool {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for String {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for ic_cdk::export::candid::Empty {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                panic!("Empty cannot be converted into JsValue");
            }
        }

        impl AzleIntoJsValue for ic_cdk::export::candid::Reserved {
            fn azle_into_js_value(self, _: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::JsValue::Null
            }
        }

        impl AzleIntoJsValue for ic_cdk::export::candid::Func {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::object::JsArray::from_iter([
                    self.principal.azle_into_js_value(context),
                    self.method.into()
                ], context).into()
            }
        }

        impl AzleIntoJsValue for ic_cdk::export::Principal {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                let exports_js_value = context.eval("exports").unwrap();
                let exports_js_object = exports_js_value.as_object().unwrap();

                let principal_class_js_value = exports_js_object.get("Principal", context).unwrap();
                let principal_class_js_object = principal_class_js_value.as_object().unwrap();

                let from_text_js_value = principal_class_js_object.get("fromText", context).unwrap();
                let from_text_js_object = from_text_js_value.as_object().unwrap();

                let principal_js_value = from_text_js_object.call(&principal_class_js_value, &[self.to_text().into()], context).unwrap();

                principal_js_value
            }
        }

        impl AzleIntoJsValue for ic_cdk::api::stable::StableMemoryError {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                match self {
                    ic_cdk::api::stable::StableMemoryError::OutOfMemory => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "OutOfMemory",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::stable::StableMemoryError::OutOfBounds => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "OutOfBounds",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                }
            }
        }

        impl AzleIntoJsValue for ic_cdk::api::call::RejectionCode {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                match self {
                    ic_cdk::api::call::RejectionCode::NoError => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "NoError",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::call::RejectionCode::SysFatal => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "SysFatal",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::call::RejectionCode::SysTransient => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "SysTransient",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::call::RejectionCode::DestinationInvalid => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "DestinationInvalid",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::call::RejectionCode::CanisterReject => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "CanisterReject",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::call::RejectionCode::CanisterError => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "CanisterError",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                    ic_cdk::api::call::RejectionCode::Unknown => {
                        boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "Unknown",
                                boa_engine::JsValue::Null,
                                boa_engine::property::Attribute::all(),
                            )
                            .build()
                            .into()
                    }
                }
            }
        }

        // Number types

        impl AzleIntoJsValue for f64 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for f32 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for ic_cdk::export::candid::Int {
            fn azle_into_js_value(self, _: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::JsValue::BigInt(boa_engine::bigint::JsBigInt::new(self.0))
            }
        }

        impl AzleIntoJsValue for i128 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::bigint::JsBigInt::new(self).into()
            }
        }

        impl AzleIntoJsValue for i64 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::JsValue::BigInt(self.into())
            }
        }

        impl AzleIntoJsValue for i32 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for i16 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for i8 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        // TODO a non-string conversion might be better
        impl AzleIntoJsValue for ic_cdk::export::candid::Nat {
            fn azle_into_js_value(self, _: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::JsValue::BigInt(boa_engine::bigint::JsBigInt::from_string(&self.0.to_string()).unwrap())
            }
        }

        impl AzleIntoJsValue for u128 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::bigint::JsBigInt::new(self).into()
            }
        }

        impl AzleIntoJsValue for u64 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                boa_engine::JsValue::BigInt(self.into())
            }
        }

        impl AzleIntoJsValue for usize {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for u32 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for u16 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for u8 {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        // Generic types

        impl<T: AzleIntoJsValue> AzleIntoJsValue for Box<T> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                (*self).azle_into_js_value(context)
            }
        }

        // TODO I wonder if we will have some problems with Option because of the type bound??
        impl<T: AzleIntoJsValue> AzleIntoJsValue for Option<T> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                match self {
                    Some(value) => value.azle_into_js_value(context),
                    None => boa_engine::JsValue::Null
                }
            }
        }

        impl<T: AzleIntoJsValue, K: AzleIntoJsValue> AzleIntoJsValue for Result<T, K> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                match self {
                    Ok(ok) => {
                        let ok_js_value = ok.azle_into_js_value(context);

                        let result_js_object = boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "ok",
                                ok_js_value,
                                boa_engine::property::Attribute::all()
                            )
                            .build();

                        let result_js_value = result_js_object.into();

                        result_js_value
                    },
                    Err(err) => {
                        let err_js_value = err.azle_into_js_value(context);

                        let result_js_object = boa_engine::object::ObjectInitializer::new(context)
                            .property(
                                "err",
                                err_js_value,
                                boa_engine::property::Attribute::all()
                            )
                            .build();

                        let result_js_value = result_js_object.into();

                        result_js_value
                    }
                }
            }
        }

        // Vec types

        impl AzleIntoJsValue for Vec<()> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<bool> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<String> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::export::candid::Empty> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::export::candid::Reserved> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::export::candid::Func> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::export::Principal> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::api::call::RejectionCode> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        // TODO add all number types
        // TODO need to figure out how to convert number Vecs to Vec<u8>
        // TODO need to abstract the number vecs out

        impl AzleIntoJsValue for Vec<f64> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<f32> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::export::candid::Int> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<i128> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<i64> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<i32> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<i16> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<i8> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<ic_cdk::export::candid::Nat> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<u128> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<u64> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<usize> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<u32> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl AzleIntoJsValue for Vec<u16> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        // TODO in the future maybe the other number types can be optimized like this (optimization implementation is currently in boa From trait impl)
        impl AzleIntoJsValue for Vec<u8> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                self.into()
            }
        }

        impl AzleIntoJsValue for Vec<Vec<u8>> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl<T: AzleIntoJsValue> AzleIntoJsValue for Vec<Box<T>> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }

        impl<T: AzleIntoJsValue> AzleIntoJsValue for Vec<Option<T>> {
            fn azle_into_js_value(self, context: &mut boa_engine::Context) -> boa_engine::JsValue {
                azle_into_js_value_generic_array(self, context)
            }
        }


        fn azle_into_js_value_generic_array<T: AzleIntoJsValue>(generic_array: Vec<T>, context: &mut boa_engine::Context) -> boa_engine::JsValue {
            let js_values = generic_array.into_iter().map(|item| item.azle_into_js_value(context)).collect::<Vec<boa_engine::JsValue>>();
            boa_engine::object::JsArray::from_iter(js_values, context).into()
        }
    
        
        #[derive(Debug)]
        pub struct AzleTryFromJsValueError(pub String);

        pub trait AzleTryFromJsValue<T> {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<T, AzleTryFromJsValueError>;
        }

        // Basic types

        impl AzleTryFromJsValue<()> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<(), AzleTryFromJsValueError> {
                if self.is_null() == true {
                    Ok(())
                }
                else {
                    Err(AzleTryFromJsValueError("JsValue is not null".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<bool> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<bool, AzleTryFromJsValueError> {
                match self.as_boolean() {
                    Some(value) => Ok(value),
                    None => Err(AzleTryFromJsValueError("JsValue is not a boolean".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<String> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<String, AzleTryFromJsValueError> {
                match self.as_string() {
                    Some(value) => Ok(value.to_string()),
                    None => Err(AzleTryFromJsValueError("JsValue is not a string".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<ic_cdk::export::candid::Empty> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<ic_cdk::export::candid::Empty, AzleTryFromJsValueError> {
                panic!("JsValue cannot be converted into Empty");
            }
        }

        impl AzleTryFromJsValue<ic_cdk::export::candid::Reserved> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<ic_cdk::export::candid::Reserved, AzleTryFromJsValueError> {
                Ok(ic_cdk::export::candid::Reserved)
            }
        }

        impl AzleTryFromJsValue<ic_cdk::export::candid::Func> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<ic_cdk::export::candid::Func, AzleTryFromJsValueError> {
                match self.as_object() {
                    Some(js_object) => {
                        match (js_object.get("0", context), js_object.get("1", context)) {
                            (Ok(principal_js_value), Ok(canister_method_text)) => {
                                match (principal_js_value.azle_try_from_js_value(context), canister_method_text.as_string()) {
                                    (Ok(principal), Some(canister_method_string)) => {
                                        Ok(ic_cdk::export::candid::Func {
                                            principal,
                                            method: canister_method_string.to_string()
                                        })
                                    },
                                    _ => Err(AzleTryFromJsValueError("principal could not be created or canister method not a string".to_string()))
                                }
                            },
                            _ => Err(AzleTryFromJsValueError("Could not retrieve index 0 or 1".to_string()))
                        }

                    },
                    None => Err(AzleTryFromJsValueError("JsValue is not an object".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<ic_cdk::export::Principal> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<ic_cdk::export::Principal, AzleTryFromJsValueError> {
                match self.as_object() {
                    Some(principal_js_object) => {
                        match principal_js_object.get("toText", context) {
                            Ok(principal_to_text_function_js_value) => {
                                match principal_to_text_function_js_value.as_object() {
                                    Some(principal_to_text_function_js_object) => {
                                        match principal_to_text_function_js_object.call(&self, &[], context) {
                                            Ok(principal_string_js_value) => {
                                                match principal_string_js_value.as_string() {
                                                    Some(principal_js_string) => {
                                                        match ic_cdk::export::Principal::from_text(principal_js_string.to_string()) {
                                                            Ok(principal) => Ok(principal),
                                                            Err(err) => Err(AzleTryFromJsValueError(err.to_string()))
                                                        }
                                                    },
                                                    None => Err(AzleTryFromJsValueError("JsValue is not a string".to_string()))
                                                }
                                            },
                                            Err(err_js_value) => {
                                                let err_js_object = err_js_value.as_object().unwrap();

                                                let err_name_js_value = err_js_object.get("name", context).unwrap();
                                                let err_message_js_value = err_js_object.get("message", context).unwrap();

                                                Err(AzleTryFromJsValueError(format!(
                                                    "{name}: {message}",
                                                    name = err_name_js_value.as_string().unwrap().to_string(),
                                                    message = err_message_js_value.as_string().unwrap().to_string()
                                                )))
                                            }
                                        }
                                    },
                                    None => Err(AzleTryFromJsValueError("JsValue is not an object".to_string()))
                                }
                            },
                            Err(err) => Err(AzleTryFromJsValueError("principal_js_object.get(\"toText\", context) failed".to_string()))
                        }
                    },
                    None => Err(AzleTryFromJsValueError("JsValue is not an object".to_string()))
                }
            }
        }

        // Number types

        impl AzleTryFromJsValue<f64> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<f64, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<f32> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<f32, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as f32),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        // TODO it would probably be better to get the BigInt out of the JsValue and convert it more directly
        // TODO but we might run into problems with Nat and BigUint, thus I am doing a string conversion for now
        impl AzleTryFromJsValue<ic_cdk::export::candid::Int> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, _: &mut boa_engine::Context) -> Result<ic_cdk::export::candid::Int, AzleTryFromJsValueError> {
                match self.as_bigint() {
                    Some(value) => Ok(ic_cdk::export::candid::Int::from_str(&value.to_string()).unwrap()), // TODO probably not the best conversion
                    None => Err(AzleTryFromJsValueError("JsValue is not a bigint".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<i128> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<i128, AzleTryFromJsValueError> {
                match self.as_bigint() {
                    Some(value) => {
                        let value_i128_result = value.to_string().parse::<i128>();

                        match value_i128_result {
                            Ok(value_i128) => Ok(value_i128),
                            Err(_) => Err(AzleTryFromJsValueError("Could not parse bigint to i128".to_string()))
                        }
                    },
                    None => Err(AzleTryFromJsValueError("JsValue is not a bigint".to_string()))
                }
            }
        }

        // TODO this might break since i64 may (will) not be a bigint
        // TODO probably need to implement my own conversion here until try_from_js_value is fixed
        impl AzleTryFromJsValue<i64> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<i64, AzleTryFromJsValueError> {
                match self.as_bigint() {
                    Some(value) => {
                        let value_i64_result = value.to_string().parse::<i64>();

                        match value_i64_result {
                            Ok(value_i64) => Ok(value_i64),
                            Err(_) => Err(AzleTryFromJsValueError("Could not parse bigint to i64".to_string()))
                        }
                    },
                    None => Err(AzleTryFromJsValueError("JsValue is not a bigint".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<i32> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<i32, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as i32),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<i16> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<i16, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as i16),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<i8> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<i8, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as i8),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<ic_cdk::export::candid::Nat> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, _: &mut boa_engine::Context) -> Result<ic_cdk::export::candid::Nat, AzleTryFromJsValueError> {
                match self.as_bigint() {
                    Some(value) => Ok(ic_cdk::export::candid::Nat::from_str(&value.to_string()).unwrap()), // TODO probably not the best conversion
                    None => Err(AzleTryFromJsValueError("JsValue is not a bigint".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<u128> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<u128, AzleTryFromJsValueError> {
                match self.as_bigint() {
                    Some(value) => {
                        let value_u128_result = value.to_string().parse::<u128>();

                        match value_u128_result {
                            Ok(value_u128) => Ok(value_u128),
                            Err(_) => Err(AzleTryFromJsValueError("Could not parse bigint to u128".to_string()))
                        }
                    },
                    None => Err(AzleTryFromJsValueError("JsValue is not a bigint".to_string()))
                }
            }
        }

        // TODO this might break since i64 may (will) not be a bigint
        // TODO probably need to implement my own conversion here until try_from_js_value is fixed
        impl AzleTryFromJsValue<u64> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<u64, AzleTryFromJsValueError> {
                match self.as_bigint() {
                    Some(value) => {
                        let value_u64_result = value.to_string().parse::<u64>();

                        match value_u64_result {
                            Ok(value_u64) => Ok(value_u64),
                            Err(_) => Err(AzleTryFromJsValueError("Could not parse bigint to u64".to_string()))
                        }
                    },
                    None => Err(AzleTryFromJsValueError("JsValue is not a bigint".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<u32> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<u32, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as u32),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<u16> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<u16, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as u16),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        impl AzleTryFromJsValue<u8> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<u8, AzleTryFromJsValueError> {
                match self.as_number() {
                    Some(value) => Ok(value as u8),
                    None => Err(AzleTryFromJsValueError("JsValue is not a number".to_string()))
                }
            }
        }

        // Generic types

        impl<T> AzleTryFromJsValue<Box<T>> for boa_engine::JsValue where boa_engine::JsValue: AzleTryFromJsValue<T> {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Box<T>, AzleTryFromJsValueError> {
                match self.azle_try_from_js_value(context) {
                    Ok(value) => Ok(Box::new(value)),
                    Err(err) => Err(err)
                }
            }
        }

        impl<T> AzleTryFromJsValue<Option<T>> for boa_engine::JsValue where boa_engine::JsValue: AzleTryFromJsValue<T> {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Option<T>, AzleTryFromJsValueError> {
                if self.is_null() {
                    Ok(None)
                }
                else {
                    match self.azle_try_from_js_value(context) {
                        Ok(value) => Ok(Some(value)),
                        Err(err) => Err(err)
                    }
                }
            }
        }

        // Vec types

        impl AzleTryFromJsValue<Vec<()>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<()>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<bool>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<bool>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<String>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<String>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<ic_cdk::export::candid::Empty>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<ic_cdk::export::candid::Empty>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<ic_cdk::export::candid::Reserved>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<ic_cdk::export::candid::Reserved>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<ic_cdk::export::candid::Func>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<ic_cdk::export::candid::Func>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<ic_cdk::export::Principal>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<ic_cdk::export::Principal>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<f64>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<f64>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<f32>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<f32>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<ic_cdk::export::candid::Int>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<ic_cdk::export::candid::Int>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<i128>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<i128>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<i64>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<i64>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<i32>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<i32>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<i16>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<i16>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<i8>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<i8>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<ic_cdk::export::candid::Nat>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<ic_cdk::export::candid::Nat>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<u128>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<u128>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<u64>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<u64>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<u32>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<u32>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<u16>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<u16>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<Vec<u8>>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<Vec<u8>>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array(self, context)
            }
        }

        impl AzleTryFromJsValue<Vec<u8>> for boa_engine::JsValue {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<u8>, AzleTryFromJsValueError> {
                Ok(
                    self
                        .as_object()
                        .unwrap()
                        .borrow()
                        .as_typed_array()
                        .unwrap()
                        .viewed_array_buffer()
                        .unwrap()
                        .borrow()
                        .as_array_buffer()
                        .unwrap()
                        .array_buffer_data
                        .clone()
                        .unwrap()
                )
            }
        }

        impl<T> AzleTryFromJsValue<Vec<Box<T>>> for boa_engine::JsValue where boa_engine::JsValue: AzleTryFromJsValue<T> {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<Box<T>>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array::<Box<T>>(self, context)
            }
        }

        impl<T> AzleTryFromJsValue<Vec<Option<T>>> for boa_engine::JsValue where boa_engine::JsValue: AzleTryFromJsValue<T> {
            fn azle_try_from_js_value(self, context: &mut boa_engine::Context) -> Result<Vec<Option<T>>, AzleTryFromJsValueError> {
                azle_try_from_js_value_generic_array::<Option<T>>(self, context)
            }
        }

        // TODO this seems like such a messy and inefficient way to do it
        fn azle_try_from_js_value_generic_array<T>(js_value: boa_engine::JsValue, context: &mut boa_engine::Context) -> Result<Vec<T>, AzleTryFromJsValueError> where boa_engine::JsValue: AzleTryFromJsValue<T> {
            match js_value.as_object() {
                Some(js_object) => {
                    if js_object.is_array() {
                        let mut processing: bool = true;
                        let mut index: usize = 0;

                        let mut result = vec![];

                        while processing == true {
                            match js_object.get(index, context) {
                                Ok(js_value) => {
                                    if js_value.is_undefined() {
                                        processing = false;
                                    }
                                    else {
                                        match js_value.azle_try_from_js_value(context) {
                                            Ok(value) => {
                                                result.push(value);
                                                index += 1;
                                            }
                                            Err(err) => {
                                                return Err(err);
                                            }
                                        }
                                    }
                                },
                                Err(_) => {
                                    return Err(AzleTryFromJsValueError("Item at array index does not exist".to_string()))
                                }
                            }
                        }

                        Ok(result)
                    }
                    else {
                        Err(AzleTryFromJsValueError("JsObject is not an array".to_string()))
                    }
                },
                None => Err(AzleTryFromJsValueError("JsValue is not an object".to_string()))
            }
        }
    

        
        
        #[ic_cdk_macros::init]
        fn init() {
            unsafe {
                BOA_CONTEXT_OPTION = Some(boa_engine::Context::default());
                let mut boa_context = BOA_CONTEXT_OPTION.as_mut().unwrap();

                
        let _azle_stable_storage = boa_engine::object::ObjectInitializer::new(&mut boa_context).build();

        let ic = boa_engine::object::ObjectInitializer::new(&mut boa_context)
            .function(
                _azle_ic_accept_message,
                "accept_message",
                0
            )
            
            .function(
                _azle_ic_arg_data_raw,
                "arg_data_raw",
                0
            )
            .function(
                _azle_ic_arg_data_raw_size,
                "arg_data_raw_size",
                0
            )
            .function(
                _azle_ic_caller,
                "caller",
                0
            )
            .function(
                _azle_ic_candid_decode,
                "candid_decode",
                0
            )
            .function(
                _azle_ic_candid_encode,
                "candid_encode",
                0
            )
            .function(
                _azle_ic_canister_balance,
                "canister_balance",
                0
            )
            .function(
                _azle_ic_canister_balance128,
                "canister_balance128",
                0
            )
            .function(
                _azle_ic_data_certificate,
                "data_certificate",
                0
            )
            .function(
                _azle_ic_id,
                "id",
                0
            )
            .function(
                _azle_ic_method_name,
                "method_name",
                0
            )
            .function(
                _azle_ic_msg_cycles_accept,
                "msg_cycles_accept",
                0
            )
            .function(
                _azle_ic_msg_cycles_accept128,
                "msg_cycles_accept128",
                0
            )
            .function(
                _azle_ic_msg_cycles_available,
                "msg_cycles_available",
                0
            )
            .function(
                _azle_ic_msg_cycles_available128,
                "msg_cycles_available128",
                0
            )
            .function(
                _azle_ic_msg_cycles_refunded,
                "msg_cycles_refunded",
                0
            )
            .function(
                _azle_ic_msg_cycles_refunded128,
                "msg_cycles_refunded128",
                0
            )
            .function(
                _azle_ic_notify_raw,
                "notify_raw",
                0
            )
            .function(
                _azle_ic_performance_counter,
                "performance_counter",
                0
            )
            .function(
                _azle_ic_print,
                "print",
                0
            )
            .function(
                _azle_ic_reject,
                "reject",
                0
            )
            .function(
                _azle_ic_reject_code,
                "reject_code",
                0
            )
            .function(
                _azle_ic_reply_raw,
                "reply_raw",
                0
            )
            .function(
                _azle_ic_reject_message,
                "reject_message",
                0
            )
            .function(
                _azle_ic_reply,
                "reply",
                0
            )
            .function(
                _azle_ic_set_certified_data,
                "set_certified_data",
                0
            )
            .function(
                _azle_ic_stable_bytes,
                "stable_bytes",
                0
            )
            .function(
                _azle_ic_stable_grow,
                "stable_grow",
                0
            )
            .function(
                _azle_ic_stable_read,
                "stable_read",
                0
            )
            .function(
                _azle_ic_stable_size,
                "stable_size",
                0
            )
            .function(
                _azle_ic_stable_write,
                "stable_write",
                0
            )
            .function(
                _azle_ic_stable64_grow,
                "stable64_grow",
                0
            )
            .function(
                _azle_ic_stable64_read,
                "stable64_read",
                0
            )
            .function(
                _azle_ic_stable64_size,
                "stable64_size",
                0
            )
            .function(
                _azle_ic_stable64_write,
                "stable64_write",
                0
            )
            .function(
                _azle_ic_time,
                "time",
                0
            )
            .function(
                _azle_ic_trap,
                "trap",
                0
            )
            
            .property(
                "_azle_stable_storage",
                _azle_stable_storage,
                boa_engine::property::Attribute::all()
            )
            .build();
    

                boa_context.register_global_property(
                    "ic",
                    ic,
                    boa_engine::property::Attribute::all()
                );

                boa_context.eval(format!(
                    "let exports = {{}}; {compiled_js}",
                    compiled_js = MAIN_JS
                )).unwrap();

                
            }
        }

        
        fn _azle_(boa_context: &mut boa_engine::Context) {
            let exports_js_value = boa_context.eval("exports").unwrap();
            let exports_js_object = exports_js_value.as_object().unwrap();

            let _js_value = exports_js_object.get("", boa_context).unwrap();
            let _js_object = _js_value.as_object().unwrap();

            let return_value = _js_object.call(
                &boa_engine::JsValue::Null,
                &[
                    
                ],
                boa_context
            ).unwrap();
        }
    
    
        
        
        #[ic_cdk_macros::pre_upgrade]
        fn pre_upgrade() {
            unsafe {
                let mut boa_context = BOA_CONTEXT_OPTION.as_mut().unwrap();

                

                // TODO there must be a better way than this eval
                let ic_js_value = boa_context.eval("globalThis.ic").unwrap();
                let ic_js_object = ic_js_value.as_object().unwrap();

                let _azle_stable_storage_js_value = ic_js_object.get("_azle_stable_storage", &mut boa_context).unwrap();
                let _azle_stable_storage_js_object = _azle_stable_storage_js_value.as_object().unwrap();

                

                // TODO should we panic ever in the pre_upgrade?? If so we should unwrap the stable_save
                
            }
        }
    
        
        #[ic_cdk_macros::post_upgrade]
        fn post_upgrade() {
            unsafe {
                BOA_CONTEXT_OPTION = Some(boa_engine::Context::default());
                let mut boa_context = BOA_CONTEXT_OPTION.as_mut().unwrap();

                boa_context.eval(format!(
                    "let exports = {{}}; {compiled_js}",
                    compiled_js = PRINCIPAL_JS
                )).unwrap();

                
        let _azle_stable_storage = boa_engine::object::ObjectInitializer::new(&mut boa_context).build();

        let ic = boa_engine::object::ObjectInitializer::new(&mut boa_context)
            .function(
                _azle_ic_accept_message,
                "accept_message",
                0
            )
            
            .function(
                _azle_ic_arg_data_raw,
                "arg_data_raw",
                0
            )
            .function(
                _azle_ic_arg_data_raw_size,
                "arg_data_raw_size",
                0
            )
            .function(
                _azle_ic_caller,
                "caller",
                0
            )
            .function(
                _azle_ic_candid_decode,
                "candid_decode",
                0
            )
            .function(
                _azle_ic_candid_encode,
                "candid_encode",
                0
            )
            .function(
                _azle_ic_canister_balance,
                "canister_balance",
                0
            )
            .function(
                _azle_ic_canister_balance128,
                "canister_balance128",
                0
            )
            .function(
                _azle_ic_data_certificate,
                "data_certificate",
                0
            )
            .function(
                _azle_ic_id,
                "id",
                0
            )
            .function(
                _azle_ic_method_name,
                "method_name",
                0
            )
            .function(
                _azle_ic_msg_cycles_accept,
                "msg_cycles_accept",
                0
            )
            .function(
                _azle_ic_msg_cycles_accept128,
                "msg_cycles_accept128",
                0
            )
            .function(
                _azle_ic_msg_cycles_available,
                "msg_cycles_available",
                0
            )
            .function(
                _azle_ic_msg_cycles_available128,
                "msg_cycles_available128",
                0
            )
            .function(
                _azle_ic_msg_cycles_refunded,
                "msg_cycles_refunded",
                0
            )
            .function(
                _azle_ic_msg_cycles_refunded128,
                "msg_cycles_refunded128",
                0
            )
            .function(
                _azle_ic_notify_raw,
                "notify_raw",
                0
            )
            .function(
                _azle_ic_performance_counter,
                "performance_counter",
                0
            )
            .function(
                _azle_ic_print,
                "print",
                0
            )
            .function(
                _azle_ic_reject,
                "reject",
                0
            )
            .function(
                _azle_ic_reject_code,
                "reject_code",
                0
            )
            .function(
                _azle_ic_reply_raw,
                "reply_raw",
                0
            )
            .function(
                _azle_ic_reject_message,
                "reject_message",
                0
            )
            .function(
                _azle_ic_reply,
                "reply",
                0
            )
            .function(
                _azle_ic_set_certified_data,
                "set_certified_data",
                0
            )
            .function(
                _azle_ic_stable_bytes,
                "stable_bytes",
                0
            )
            .function(
                _azle_ic_stable_grow,
                "stable_grow",
                0
            )
            .function(
                _azle_ic_stable_read,
                "stable_read",
                0
            )
            .function(
                _azle_ic_stable_size,
                "stable_size",
                0
            )
            .function(
                _azle_ic_stable_write,
                "stable_write",
                0
            )
            .function(
                _azle_ic_stable64_grow,
                "stable64_grow",
                0
            )
            .function(
                _azle_ic_stable64_read,
                "stable64_read",
                0
            )
            .function(
                _azle_ic_stable64_size,
                "stable64_size",
                0
            )
            .function(
                _azle_ic_stable64_write,
                "stable64_write",
                0
            )
            .function(
                _azle_ic_time,
                "time",
                0
            )
            .function(
                _azle_ic_trap,
                "trap",
                0
            )
            
            .property(
                "_azle_stable_storage",
                _azle_stable_storage,
                boa_engine::property::Attribute::all()
            )
            .build();
    

                boa_context.register_global_property(
                    "ic",
                    ic,
                    boa_engine::property::Attribute::all()
                );

                boa_context.eval(format!(
                    "{compiled_js}",
                    compiled_js = MAIN_JS
                )).unwrap();

                
            }
        }
    
        
    

        # [ic_cdk_macros :: query] async fn balance (arg0 : String) -> u64 { unsafe { let mut boa_context = BOA_CONTEXT_OPTION . as_mut () . unwrap () ; let exports_js_value = boa_context . eval ("exports") . unwrap () ; let exports_js_object = exports_js_value . as_object () . unwrap () ; let balance_js_value = exports_js_object . get ("balance" , & mut boa_context) . unwrap () ; let balance_js_object = balance_js_value . as_object () . unwrap () ; let _azle_return_value = balance_js_object . call (& boa_engine :: JsValue :: Null , & [arg0 . azle_into_js_value (& mut boa_context)] , & mut boa_context) . unwrap () ; if _azle_return_value . is_object () == false || _azle_return_value . as_object () . unwrap () . is_generator () == false { return _azle_return_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } let _azle_final_js_value = handle_generator_result (& mut boa_context , & _azle_return_value) . await ; return _azle_final_js_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } } # [ic_cdk_macros :: update] async fn initializeSupply (arg0 : String , arg1 : String , arg2 : u64 , arg3 : String) -> bool { unsafe { let mut boa_context = BOA_CONTEXT_OPTION . as_mut () . unwrap () ; let exports_js_value = boa_context . eval ("exports") . unwrap () ; let exports_js_object = exports_js_value . as_object () . unwrap () ; let initializeSupply_js_value = exports_js_object . get ("initializeSupply" , & mut boa_context) . unwrap () ; let initializeSupply_js_object = initializeSupply_js_value . as_object () . unwrap () ; let _azle_return_value = initializeSupply_js_object . call (& boa_engine :: JsValue :: Null , & [arg0 . azle_into_js_value (& mut boa_context) , arg1 . azle_into_js_value (& mut boa_context) , arg2 . azle_into_js_value (& mut boa_context) , arg3 . azle_into_js_value (& mut boa_context)] , & mut boa_context) . unwrap () ; if _azle_return_value . is_object () == false || _azle_return_value . as_object () . unwrap () . is_generator () == false { return _azle_return_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } let _azle_final_js_value = handle_generator_result (& mut boa_context , & _azle_return_value) . await ; return _azle_final_js_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } } # [ic_cdk_macros :: query] async fn name () -> String { unsafe { let mut boa_context = BOA_CONTEXT_OPTION . as_mut () . unwrap () ; let exports_js_value = boa_context . eval ("exports") . unwrap () ; let exports_js_object = exports_js_value . as_object () . unwrap () ; let name_js_value = exports_js_object . get ("name" , & mut boa_context) . unwrap () ; let name_js_object = name_js_value . as_object () . unwrap () ; let _azle_return_value = name_js_object . call (& boa_engine :: JsValue :: Null , & [] , & mut boa_context) . unwrap () ; if _azle_return_value . is_object () == false || _azle_return_value . as_object () . unwrap () . is_generator () == false { return _azle_return_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } let _azle_final_js_value = handle_generator_result (& mut boa_context , & _azle_return_value) . await ; return _azle_final_js_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } } # [ic_cdk_macros :: query] async fn ticker () -> String { unsafe { let mut boa_context = BOA_CONTEXT_OPTION . as_mut () . unwrap () ; let exports_js_value = boa_context . eval ("exports") . unwrap () ; let exports_js_object = exports_js_value . as_object () . unwrap () ; let ticker_js_value = exports_js_object . get ("ticker" , & mut boa_context) . unwrap () ; let ticker_js_object = ticker_js_value . as_object () . unwrap () ; let _azle_return_value = ticker_js_object . call (& boa_engine :: JsValue :: Null , & [] , & mut boa_context) . unwrap () ; if _azle_return_value . is_object () == false || _azle_return_value . as_object () . unwrap () . is_generator () == false { return _azle_return_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } let _azle_final_js_value = handle_generator_result (& mut boa_context , & _azle_return_value) . await ; return _azle_final_js_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } } # [ic_cdk_macros :: query] async fn totalSupply () -> u64 { unsafe { let mut boa_context = BOA_CONTEXT_OPTION . as_mut () . unwrap () ; let exports_js_value = boa_context . eval ("exports") . unwrap () ; let exports_js_object = exports_js_value . as_object () . unwrap () ; let totalSupply_js_value = exports_js_object . get ("totalSupply" , & mut boa_context) . unwrap () ; let totalSupply_js_object = totalSupply_js_value . as_object () . unwrap () ; let _azle_return_value = totalSupply_js_object . call (& boa_engine :: JsValue :: Null , & [] , & mut boa_context) . unwrap () ; if _azle_return_value . is_object () == false || _azle_return_value . as_object () . unwrap () . is_generator () == false { return _azle_return_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } let _azle_final_js_value = handle_generator_result (& mut boa_context , & _azle_return_value) . await ; return _azle_final_js_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } } # [ic_cdk_macros :: update] async fn transfer (arg0 : String , arg1 : String , arg2 : u64) -> bool { unsafe { let mut boa_context = BOA_CONTEXT_OPTION . as_mut () . unwrap () ; let exports_js_value = boa_context . eval ("exports") . unwrap () ; let exports_js_object = exports_js_value . as_object () . unwrap () ; let transfer_js_value = exports_js_object . get ("transfer" , & mut boa_context) . unwrap () ; let transfer_js_object = transfer_js_value . as_object () . unwrap () ; let _azle_return_value = transfer_js_object . call (& boa_engine :: JsValue :: Null , & [arg0 . azle_into_js_value (& mut boa_context) , arg1 . azle_into_js_value (& mut boa_context) , arg2 . azle_into_js_value (& mut boa_context)] , & mut boa_context) . unwrap () ; if _azle_return_value . is_object () == false || _azle_return_value . as_object () . unwrap () . is_generator () == false { return _azle_return_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } let _azle_final_js_value = handle_generator_result (& mut boa_context , & _azle_return_value) . await ; return _azle_final_js_value . azle_try_from_js_value (& mut boa_context) . unwrap () ; } }

        
        #[async_recursion::async_recursion(?Send)]
        async fn handle_generator_result(
            _azle_boa_context: &mut boa_engine::Context,
            _azle_return_value: &boa_engine::JsValue
        ) -> boa_engine::JsValue {
            let _azle_generator_object = _azle_return_value.as_object().unwrap();

            let _azle_next_js_value = _azle_generator_object.get("next", _azle_boa_context).unwrap();
            let _azle_next_js_object = _azle_next_js_value.as_object().unwrap();

            let mut _azle_continue_running = true;
            let mut _azle_args: Vec<boa_engine::JsValue> = vec![];

            // let mut _azle_final_js_value = boa_engine::JsValue::Undefined; // TODO this will probably break down below
            let mut _azle_final_js_value = boa_engine::JsValue::from("hello"); // TODO this will probably break down below

            while _azle_continue_running == true {
                let yield_result_js_value = _azle_next_js_object.call(&_azle_return_value, &_azle_args[..], _azle_boa_context).unwrap();
                let yield_result_js_object = yield_result_js_value.as_object().unwrap();

                let yield_result_done_js_value = yield_result_js_object.get("done", _azle_boa_context).unwrap();
                let yield_result_done_bool = yield_result_done_js_value.as_boolean().unwrap();

                let yield_result_value_js_value = yield_result_js_object.get("value", _azle_boa_context).unwrap();

                if yield_result_done_bool == false {
                    let yield_result_value_js_object = yield_result_value_js_value.as_object().unwrap();

                    if yield_result_value_js_object.is_generator() {
                        let recursed_generator_js_value = handle_generator_result(
                            _azle_boa_context,
                            &yield_result_value_js_value
                        ).await;

                        _azle_args = vec![recursed_generator_js_value];

                        continue;
                    }

                    let name_js_value = yield_result_value_js_object.get("name", _azle_boa_context).unwrap();
                    let name_string = name_js_value.as_string().unwrap();

                    if name_string == "rawRand" {
                        let call_result: Result<(Vec<u8>,()), _> = ic_cdk::api::call::call(
                            ic_cdk::export::Principal::management_canister(),
                            "raw_rand",
                            ()
                        ).await;

                        match call_result {
                            Ok(value) => {
                                let js_value = value.0.azle_into_js_value(_azle_boa_context);

                                let canister_result_js_object = boa_engine::object::ObjectInitializer::new(_azle_boa_context)
                                    .property(
                                        "ok",
                                        js_value,
                                        boa_engine::property::Attribute::all()
                                    )
                                    .build();

                                let canister_result_js_value = canister_result_js_object.into();

                                _azle_args = vec![canister_result_js_value];
                            },
                            Err(err) => {
                                let js_value = format!("Rejection code {rejection_code}, {error_message}", rejection_code = (err.0 as i32).to_string(), error_message = err.1).azle_into_js_value(_azle_boa_context);

                                let canister_result_js_object = boa_engine::object::ObjectInitializer::new(_azle_boa_context)
                                    .property(
                                        "err",
                                        js_value,
                                        boa_engine::property::Attribute::all()
                                    )
                                    .build();

                                let canister_result_js_value = canister_result_js_object.into();

                                _azle_args = vec![canister_result_js_value];
                            }
                        };
                    }

                    // TODO call_raw and call_raw128 code are nearly identical
                    if name_string == "call_raw" {
                        let call_args_js_value = yield_result_value_js_object.get("args", _azle_boa_context).unwrap();
                        let call_args_js_object = call_args_js_value.as_object().unwrap();

                        let canister_id_js_value = call_args_js_object.get("0", _azle_boa_context).unwrap();
                        let canister_id_principal: ic_cdk::export::Principal = canister_id_js_value.azle_try_from_js_value(_azle_boa_context).unwrap();

                        let method_js_value = call_args_js_object.get("1", _azle_boa_context).unwrap();
                        let method_string = method_js_value.as_string().unwrap().to_string();

                        // TODO use azle_try_from_js_value more often
                        let args_raw_js_value = call_args_js_object.get("2", _azle_boa_context).unwrap();
                        let args_raw_vec: Vec<u8> = args_raw_js_value.azle_try_from_js_value(_azle_boa_context).unwrap();

                        let payment_js_value = call_args_js_object.get("3", _azle_boa_context).unwrap();
                        let payment: u64 = payment_js_value.azle_try_from_js_value(_azle_boa_context).unwrap();

                        let call_result: Result<Vec<u8>, _> = ic_cdk::api::call::call_raw(
                            canister_id_principal,
                            &method_string,
                            &args_raw_vec,
                            payment
                        ).await;

                        match call_result {
                            Ok(value) => {
                                let js_value = value.azle_into_js_value(_azle_boa_context);

                                let canister_result_js_object = boa_engine::object::ObjectInitializer::new(_azle_boa_context)
                                    .property(
                                        "ok",
                                        js_value,
                                        boa_engine::property::Attribute::all()
                                    )
                                    .build();

                                let canister_result_js_value = canister_result_js_object.into();

                                _azle_args = vec![canister_result_js_value];
                            },
                            Err(err) => {
                                let js_value = format!("Rejection code {rejection_code}, {error_message}", rejection_code = (err.0 as i32).to_string(), error_message = err.1).azle_into_js_value(_azle_boa_context);

                                let canister_result_js_object = boa_engine::object::ObjectInitializer::new(_azle_boa_context)
                                    .property(
                                        "err",
                                        js_value,
                                        boa_engine::property::Attribute::all()
                                    )
                                    .build();

                                let canister_result_js_value = canister_result_js_object.into();

                                _azle_args = vec![canister_result_js_value];
                            }
                        };
                    }

                    // TODO call_raw and call_raw128 code are nearly identical
                    if name_string == "call_raw128" {
                        let call_args_js_value = yield_result_value_js_object.get("args", _azle_boa_context).unwrap();
                        let call_args_js_object = call_args_js_value.as_object().unwrap();

                        let canister_id_js_value = call_args_js_object.get("0", _azle_boa_context).unwrap();
                        let canister_id_principal: ic_cdk::export::Principal = canister_id_js_value.azle_try_from_js_value(_azle_boa_context).unwrap();

                        let method_js_value = call_args_js_object.get("1", _azle_boa_context).unwrap();
                        let method_string = method_js_value.as_string().unwrap().to_string();

                        // TODO use azle_try_from_js_value more often
                        let args_raw_js_value = call_args_js_object.get("2", _azle_boa_context).unwrap();
                        let args_raw_vec: Vec<u8> = args_raw_js_value.azle_try_from_js_value(_azle_boa_context).unwrap();

                        let payment_js_value = call_args_js_object.get("3", _azle_boa_context).unwrap();
                        let payment: u128 = payment_js_value.azle_try_from_js_value(_azle_boa_context).unwrap();

                        let call_result: Result<Vec<u8>, _> = ic_cdk::api::call::call_raw128(
                            canister_id_principal,
                            &method_string,
                            &args_raw_vec,
                            payment
                        ).await;

                        match call_result {
                            Ok(value) => {
                                let js_value = value.azle_into_js_value(_azle_boa_context);

                                let canister_result_js_object = boa_engine::object::ObjectInitializer::new(_azle_boa_context)
                                    .property(
                                        "ok",
                                        js_value,
                                        boa_engine::property::Attribute::all()
                                    )
                                    .build();

                                let canister_result_js_value = canister_result_js_object.into();

                                _azle_args = vec![canister_result_js_value];
                            },
                            Err(err) => {
                                let js_value = format!("Rejection code {rejection_code}, {error_message}", rejection_code = (err.0 as i32).to_string(), error_message = err.1).azle_into_js_value(_azle_boa_context);

                                let canister_result_js_object = boa_engine::object::ObjectInitializer::new(_azle_boa_context)
                                    .property(
                                        "err",
                                        js_value,
                                        boa_engine::property::Attribute::all()
                                    )
                                    .build();

                                let canister_result_js_value = canister_result_js_object.into();

                                _azle_args = vec![canister_result_js_value];
                            }
                        };
                    }

                    if name_string == "call" {
                        let call_args_js_value = yield_result_value_js_object.get("args", _azle_boa_context).unwrap();
                        let call_args_js_object = call_args_js_value.as_object().unwrap();

                        let call_function_name_js_value = call_args_js_object.get("0", _azle_boa_context).unwrap();
                        let call_function_name_string = call_function_name_js_value.as_string().unwrap().to_string();

                        match &call_function_name_string[..] {
                            
                            _ => ()
                        };
                    }

                    if name_string == "call_with_payment" {
                        let call_args_js_value = yield_result_value_js_object.get("args", _azle_boa_context).unwrap();
                        let call_args_js_object = call_args_js_value.as_object().unwrap();

                        let call_function_name_js_value = call_args_js_object.get("0", _azle_boa_context).unwrap();
                        let call_function_name_string = call_function_name_js_value.as_string().unwrap().to_string();

                        match &call_function_name_string[..] {
                            
                            _ => ()
                        };
                    }

                    if name_string == "call_with_payment128" {
                        let call_args_js_value = yield_result_value_js_object.get("args", _azle_boa_context).unwrap();
                        let call_args_js_object = call_args_js_value.as_object().unwrap();

                        let call_function_name_js_value = call_args_js_object.get("0", _azle_boa_context).unwrap();
                        let call_function_name_string = call_function_name_js_value.as_string().unwrap().to_string();

                        match &call_function_name_string[..] {
                            
                            _ => ()
                        };
                    }
                }
                else {
                    _azle_final_js_value = yield_result_value_js_value;
                    _azle_continue_running = false;
                }
            }

            _azle_final_js_value
        }
    

        
        
        fn _azle_ic_accept_message(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::call::accept_message().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_arg_data(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let top_level_call_frame = get_top_level_call_frame(&_context.vm.frame.as_ref().unwrap());
            let function_name_sym = top_level_call_frame.code.name;
            let function_name = &_context.interner.resolve_expect(function_name_sym.clone());

            match &function_name[..] {
                
                        "balance" => {
                            let arg_data: (String,) = ic_cdk::api::call::arg_data();

                            let arg_js_values = vec![arg_data.0.azle_into_js_value(_context)];

                            let arg_data_js_array = boa_engine::object::JsArray::from_iter(arg_js_values, _context);
                            Ok(arg_data_js_array.into())
                        }
                    ,

                        "ticker" => {
                            let arg_data: () = ic_cdk::api::call::arg_data();

                            let arg_js_values = vec![];

                            let arg_data_js_array = boa_engine::object::JsArray::from_iter(arg_js_values, _context);
                            Ok(arg_data_js_array.into())
                        }
                    ,

                        "name" => {
                            let arg_data: () = ic_cdk::api::call::arg_data();

                            let arg_js_values = vec![];

                            let arg_data_js_array = boa_engine::object::JsArray::from_iter(arg_js_values, _context);
                            Ok(arg_data_js_array.into())
                        }
                    ,

                        "totalSupply" => {
                            let arg_data: () = ic_cdk::api::call::arg_data();

                            let arg_js_values = vec![];

                            let arg_data_js_array = boa_engine::object::JsArray::from_iter(arg_js_values, _context);
                            Ok(arg_data_js_array.into())
                        }
                    ,

                        "initializeSupply" => {
                            let arg_data: (String, String, u64, String,) = ic_cdk::api::call::arg_data();

                            let arg_js_values = vec![arg_data.0.azle_into_js_value(_context), arg_data.1.azle_into_js_value(_context), arg_data.2.azle_into_js_value(_context), arg_data.3.azle_into_js_value(_context)];

                            let arg_data_js_array = boa_engine::object::JsArray::from_iter(arg_js_values, _context);
                            Ok(arg_data_js_array.into())
                        }
                    ,

                        "transfer" => {
                            let arg_data: (String, String, u64,) = ic_cdk::api::call::arg_data();

                            let arg_js_values = vec![arg_data.0.azle_into_js_value(_context), arg_data.1.azle_into_js_value(_context), arg_data.2.azle_into_js_value(_context)];

                            let arg_data_js_array = boa_engine::object::JsArray::from_iter(arg_js_values, _context);
                            Ok(arg_data_js_array.into())
                        }
                    
                _ => panic!("This cannot happen")
            }
        }
    
        
        fn _azle_ic_arg_data_raw(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::call::arg_data_raw().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_arg_data_raw_size(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::call::arg_data_raw_size().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_caller(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::caller().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_candid_decode(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let candid_encoded: Vec<u8> = _aargs.get(0).unwrap().clone().azle_try_from_js_value(_context).unwrap();
            let candid_args: candid::IDLArgs = candid::IDLArgs::from_bytes(&candid_encoded).unwrap();
            let candid_string = candid_args.to_string();

            Ok(candid_string.azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_candid_encode(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let candid_string = _aargs.get(0).unwrap().as_string().unwrap();
            let candid_args: candid::IDLArgs = candid_string.parse().unwrap();
            let candid_encoded: Vec<u8> = candid_args.to_bytes().unwrap();

            Ok(candid_encoded.azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_canister_balance(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::canister_balance().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_canister_balance128(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::canister_balance128().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_data_certificate(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::data_certificate().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_id(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::id().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_method_name(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::call::method_name().into())
        }
    
        
        fn _azle_ic_msg_cycles_accept(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let max_amount: u64 = _aargs[0].clone().azle_try_from_js_value(_context).unwrap();
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::msg_cycles_accept(max_amount).into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_msg_cycles_accept128(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let max_amount: u128 = _aargs[0].clone().azle_try_from_js_value(_context).unwrap();
            // TODO: This extra conversion may not be necessary once
            // https://github.com/boa-dev/boa/issues/1970 is implemented.
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::msg_cycles_accept128(max_amount).into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_msg_cycles_available(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::msg_cycles_available().into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_msg_cycles_available128(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            // TODO: This extra conversion may not be necessary once
            // https://github.com/boa-dev/boa/issues/1970 is implemented.
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::msg_cycles_available().into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_msg_cycles_refunded(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::msg_cycles_refunded().into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_msg_cycles_refunded128(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::msg_cycles_refunded128().into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_notify_raw(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let canister_id_js_value = _aargs.get(0).unwrap().clone();
            let canister_id_principal: ic_cdk::export::Principal = canister_id_js_value.azle_try_from_js_value(_context).unwrap();

            let method_js_value = _aargs.get(1).unwrap().clone();
            let method_string = method_js_value.as_string().unwrap().to_string();

            let args_raw_js_value = _aargs.get(2).unwrap().clone();
            let args_raw_vec: Vec<u8> = args_raw_js_value.azle_try_from_js_value(_context).unwrap();

            let payment_js_value = _aargs.get(3).unwrap().clone();
            let payment: u128 = payment_js_value.azle_try_from_js_value(_context).unwrap();

            let notify_result = ic_cdk::api::call::notify_raw(
                canister_id_principal,
                &method_string,
                &args_raw_vec,
                payment
            );

            Ok(notify_result.azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_performance_counter(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let counter_type: u32 = _aargs[0].clone().azle_try_from_js_value(_context).unwrap();
            let return_value: boa_engine::bigint::JsBigInt = ic_cdk::api::call::performance_counter(counter_type).into();
            Ok(return_value.into())
        }
    
        
        fn _azle_ic_print(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            ic_cdk::println!("{:#?}", _aargs);

            return Ok(boa_engine::JsValue::Undefined);
        }
    
        
        fn _azle_ic_reject(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(
                ic_cdk::api::call::reject(_aargs.get(0).unwrap().as_string().unwrap())
                    .azle_into_js_value(_context)
            )
        }
    
        
        fn _azle_ic_reject_code(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::call::reject_code().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_reject_message(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::call::reject_message().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_reply(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let top_level_call_frame = get_top_level_call_frame(&_context.vm.frame.as_ref().unwrap());
            let function_name_sym = top_level_call_frame.code.name;
            let function_name = &_context.interner.resolve_expect(function_name_sym.clone());

            match &function_name[..] {
                
                _ => panic!("This cannot happen")
            }
        }
    
        
        fn _azle_ic_reply_raw(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let buf_js_value: boa_engine::JsValue = _aargs.get(0).unwrap().clone();
            let buf_vec: Vec<u8> = buf_js_value.azle_try_from_js_value(_context).unwrap();
            Ok(ic_cdk::api::call::reply_raw(&buf_vec).azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_set_certified_data(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let data_js_value: boa_engine::JsValue = _aargs.get(0).unwrap().clone();
            let data_vec: Vec<u8> = data_js_value.azle_try_from_js_value(_context).unwrap();
            Ok(ic_cdk::api::set_certified_data(&data_vec).azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable_bytes(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::stable::stable_bytes().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable_grow(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let new_pages: u32 = _aargs
                .get(0)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            Ok(ic_cdk::api::stable::stable_grow(new_pages).azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable_read(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let offset: u32 = _aargs
                .get(0)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            let length: u32 = _aargs
                .get(1)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();

            let mut buf: Vec<u8> = vec![0; length as usize];
            ic_cdk::api::stable::stable_read(offset, &mut buf);
            Ok(buf.azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable_size(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::stable::stable_size().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable_write(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let offset: u32 = _aargs
                .get(0)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            let buf_vector: Vec<u8> = _aargs
                .get(1)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            let buf: &[u8] = &buf_vector[..];
            ic_cdk::api::stable::stable_write(offset, buf);
            Ok(boa_engine::JsValue::Undefined)
        }
    
        
        fn _azle_ic_stable64_grow(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let new_pages: u64 = _aargs
                .get(0)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            Ok(ic_cdk::api::stable::stable64_grow(new_pages).azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable64_read(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let offset: u64 = _aargs
                .get(0)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            let length: u64 = _aargs
                .get(1)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();

            let mut buf: Vec<u8> = vec![0; length as usize];
            ic_cdk::api::stable::stable64_read(offset, &mut buf);
            Ok(buf.to_vec().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable64_size(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::stable::stable64_size().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_stable64_write(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context,
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            let offset: u64 = _aargs
                .get(0)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            let buf_vector: Vec<u8> = _aargs
                .get(1)
                .unwrap()
                .clone()
                .azle_try_from_js_value(_context)
                .unwrap();
            let buf: &[u8] = &buf_vector[..];
            ic_cdk::api::stable::stable64_write(offset, buf);
            Ok(boa_engine::JsValue::Undefined)
        }
    
        
        fn _azle_ic_time(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            Ok(ic_cdk::api::time().azle_into_js_value(_context))
        }
    
        
        fn _azle_ic_trap(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            ic_cdk::api::trap(_aargs.get(0).unwrap().as_string().unwrap());
        }
    
  

        

        fn get_top_level_call_frame(call_frame: &boa_engine::vm::call_frame::CallFrame) -> boa_engine::vm::call_frame::CallFrame {
            if let Some(prev_call_frame) = &call_frame.prev {
                return get_top_level_call_frame(&prev_call_frame);
            }
            else {
                return call_frame.clone();
            }
        }
    