import * as tsplus_module_1 from "@fp-ts/data/Option";
import * as tsplus_module_2 from "@fp-ts/data/Either";
import * as tsplus_module_3 from "dfx/common";
import * as tsplus_module_4 from "@effect/io/Layer";
import * as tsplus_module_5 from "@fp-ts/data/Function";
import * as tsplus_module_6 from "@effect/io/Effect";
import Nacl from "tweetnacl";
import { handlers } from "./handlers.js";
import { fromHex } from "./utils.js";
export class BadWebhookSignature {
    _tag = "BadWebhookSignature";
}
const checkSignature = (publicKey, headers, body) => tsplus_module_2.asUnit(tsplus_module_1.toEither(() => new BadWebhookSignature())(tsplus_module_1.filter((a) => {
    const enc = new TextEncoder();
    return Nacl.sign.detached.verify(enc.encode(a.timestamp + body), fromHex(`${a.signature}`), publicKey);
})(tsplus_module_1.struct({
    signature: tsplus_module_1.fromNullable(headers["x-signature-ed25519"]),
    timestamp: tsplus_module_1.fromNullable(headers["x-signature-timestamp"]),
}))));
const makeConfig = ({ applicationId, publicKey }) => ({
    applicationId,
    publicKey: fromHex(publicKey),
});
export const WebhookConfig = tsplus_module_3.Tag();
export const makeConfigLayer = tsplus_module_5.flow(makeConfig, tsplus_module_4.succeed(WebhookConfig));
export class WebhookParseError {
    reason;
    _tag = "WebhookParseError";
    constructor(reason) {
        this.reason = reason;
    }
}
const fromHeadersAndBody = (headers, body) => tsplus_module_6.flatMap(({ publicKey }) => tsplus_module_6.flatMap(() => tsplus_module_6.tryCatch(() => JSON.parse(body), (reason) => new WebhookParseError(reason)))(tsplus_module_6.fromEither(checkSignature(publicKey, headers, body))))(tsplus_module_6.service(WebhookConfig));
const run = (definitions) => {
    const handler = handlers(definitions);
    return (headers, body) => tsplus_module_6.flatMap(interaction => handler[interaction.type](interaction))(fromHeadersAndBody(headers, body));
};
export const makeHandler = (ix) => {
    const handle = run(ix.definitions);
    return ({ headers, body, success, empty, error, }) => tsplus_module_6.catchAllCause(error)(tsplus_module_6.flatMap((o) => tsplus_module_1.match(() => empty, (a) => success(a))(o))(handle(headers, body)));
};
//# sourceMappingURL=webhook.js.map