import { Discord, Maybe } from "dfx/common";
/**
 * Maybe find a sub-command within the interaction options.
 */
export declare const allSubCommands: (interaction: Discord.ApplicationCommandDatum) => readonly import("../types.js").ApplicationCommandInteractionDataOption[];
/**
 * Maybe find a sub-command within the interaction options.
 */
export declare const findSubCommand: (name: string) => (interaction: Discord.ApplicationCommandDatum) => import("../common.js").Maybe<import("../types.js").ApplicationCommandInteractionDataOption>;
/**
 * If the sub-command exists return `true`, else `false`.
 */
export declare const isSubCommand: (name: string) => (interaction: import("../types.js").ApplicationCommandDatum) => boolean;
/**
 * Maybe get the options for a sub-command
 */
export declare const subCommandOptions: (name: string) => (interaction: import("../types.js").ApplicationCommandDatum) => import("../common.js").Maybe<import("../types.js").ApplicationCommandInteractionDataOption[]>;
/**
 * A lens for accessing nested options in a interaction.
 */
export declare const optionsWithNested: (data: Pick<Discord.ApplicationCommandDatum, "options">) => Discord.ApplicationCommandInteractionDataOption[];
/**
 * Return the interaction options as a name / value map.
 */
export declare const transformOptions: (options: Discord.ApplicationCommandInteractionDataOption[]) => Record<string, string | undefined>;
/**
 * Return the interaction options as a name / value map.
 */
export declare const optionsMap: (data: Pick<import("../types.js").ApplicationCommandDatum, "options">) => Record<string, string | undefined>;
/**
 * Try find a matching option from the interaction.
 */
export declare const getOption: (name: string) => (data: Pick<import("../types.js").ApplicationCommandDatum, "options">) => import("../common.js").Maybe<import("../types.js").ApplicationCommandInteractionDataOption>;
/**
 * Try find a matching option from the interaction.
 */
export declare const focusedOption: (data: Pick<import("../types.js").ApplicationCommandDatum, "options">) => import("../common.js").Maybe<import("../types.js").ApplicationCommandInteractionDataOption>;
/**
 * Try find a matching option value from the interaction.
 */
export declare const optionValue: (name: string) => (data: Pick<import("../types.js").ApplicationCommandDatum, "options">) => import("../common.js").Maybe<string>;
/**
 * Try extract resolved data
 */
export declare const resolved: (data: Discord.ApplicationCommandDatum) => import("../common.js").Maybe<import("../types.js").ResolvedDatum>;
/**
 * Try find a matching option value from the interaction.
 */
export declare const resolveOptionValue: <T>(name: string, f: (id: Discord.Snowflake, data: Discord.ResolvedDatum) => T | undefined) => (a: Discord.ApplicationCommandDatum) => import("../common.js").Maybe<T>;
/**
 * A lens for accessing the components in a interaction.
 */
export declare const components: (a: Discord.ModalSubmitDatum) => Discord.Component[];
/**
 * A lens for accessing the components in a interaction.
 */
export declare const componentsWithValue: (a: import("../types.js").ModalSubmitDatum) => readonly import("../types.js").Component[];
/**
 * Return the interaction components as an id / value map.
 */
export declare const transformComponents: (options: Discord.Component[]) => Record<string, string | undefined>;
/**
 * Return the interaction components as an id / value map.
 */
export declare const componentsMap: (a: import("../types.js").ModalSubmitDatum) => Record<string, string | undefined>;
/**
 * Try find a matching component from the interaction.
 */
export declare const getComponent: (id: string) => (a: import("../types.js").ModalSubmitDatum) => import("../common.js").Maybe<import("../types.js").Component>;
/**
 * Try find a matching component value from the interaction.
 */
export declare const componentValue: (id: string) => (a: import("../types.js").ModalSubmitDatum) => import("../common.js").Maybe<string>;
//# sourceMappingURL=interactions.d.ts.map