import * as tsplus_module_1 from "@effect/io/Effect";
import * as tsplus_module_2 from "@effect/io/Ref";
import * as tsplus_module_3 from "callbag-effect-ts/Source/async";
import * as tsplus_module_4 from "callbag-effect-ts/Source/unwrap";
import * as tsplus_module_5 from "callbag-effect-ts/Source/tap";
import * as tsplus_module_6 from "callbag-effect-ts/Source/drain";
import * as tsplus_module_7 from "dfx/common";
import * as tsplus_module_8 from "@effect/io/Schedule";
import * as tsplus_module_9 from "callbag-effect-ts/Source/merge";
import * as tsplus_module_10 from "callbag-effect-ts/Source/unwrapScope";
import * as tsplus_module_11 from "callbag-effect-ts/Source/retry";
import WebSocket from "isomorphic-ws";
export const Reconnect = Symbol();
const socket = (urlRef, options) => tsplus_module_1.acquireRelease(tsplus_module_1.map(url => new WebSocket(url, options))(tsplus_module_2.get(urlRef)), (ws) => tsplus_module_1.sync(() => {
    ws.close();
    ws.removeAllListeners();
}));
export class WebSocketError {
    reason;
    _tag = "WebSocketError";
    constructor(reason) {
        this.reason = reason;
    }
}
export class WebSocketCloseError {
    code;
    reason;
    _tag = "WebSocketCloseError";
    constructor(code, reason) {
        this.code = code;
        this.reason = reason;
    }
}
const recv = (ws) => tsplus_module_3.async((emit) => {
    ws.on("message", (message) => {
        emit.data(message);
    });
    ws.on("error", (cause) => {
        emit.fail(new WebSocketError(cause));
    });
    ws.on("close", (code, reason) => {
        emit.fail(new WebSocketCloseError(code, reason.toString("utf8")));
    });
});
export class WebSocketWriteError {
    reason;
    _tag = "WebSocketWriteError";
    constructor(reason) {
        this.reason = reason;
    }
}
const send = (ws, out) => tsplus_module_1.map(log => tsplus_module_6.drain(tsplus_module_5.tap((data) => tsplus_module_1.async((resume) => {
    if (data === Reconnect) {
        ws.close(1012, "reconnecting");
        resume(tsplus_module_1.unit());
    }
    else {
        ws.send(data, (err) => {
            resume(err
                ? tsplus_module_1.fail(new WebSocketWriteError(err))
                : tsplus_module_1.unit());
        });
    }
}))(tsplus_module_5.tap((p) => log.debug("WS", "send", p))(tsplus_module_4.unwrap(tsplus_module_1.map(() => out)(tsplus_module_1.async((resume) => {
    if (ws.readyState & ws.OPEN) {
        resume(tsplus_module_1.unit());
    }
    else {
        ws.once("open", () => {
            resume(tsplus_module_1.unit());
        });
    }
})))))))(tsplus_module_1.service(tsplus_module_7.Log.Log));
export const make = (url, options) => (() => {
    const [sink, outbound] = tsplus_module_3.asyncSink();
    return tsplus_module_1.map(log => {
        const withLog = tsplus_module_1.provideService(tsplus_module_7.Log.Log)(log);
        const source = tsplus_module_11.retry(tsplus_module_8.recurWhile((e) => e._tag === "WebSocketCloseError" && e.code === 1012))(tsplus_module_10.unwrapScope(tsplus_module_1.flatMap(ws => tsplus_module_1.map(sendEffect => tsplus_module_9.merge(sendEffect)(recv(ws)))(withLog(send(ws, outbound))))(socket(url, options))));
        return { source, sink };
    })(tsplus_module_1.service(tsplus_module_7.Log.Log));
})();
//# sourceMappingURL=index.js.map