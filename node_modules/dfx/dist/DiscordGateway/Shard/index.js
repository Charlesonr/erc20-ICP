import * as tsplus_module_1 from "@effect/io/Effect";
import * as tsplus_module_2 from "dfx/common-gateway";
import * as tsplus_module_3 from "callbag-effect-ts/Source/forEach";
import * as tsplus_module_4 from "dfx/common";
import * as tsplus_module_5 from "callbag-effect-ts/Source/filter";
import * as tsplus_module_6 from "callbag-effect-ts/Source/tap";
import * as tsplus_module_7 from "callbag-effect-ts/Source/run";
import * as tsplus_module_8 from "@fp-ts/data/Option";
import * as tsplus_module_9 from "callbag-effect-ts/Source/share";
import * as tsplus_module_10 from "@fp-ts/data/Duration";
import * as tsplus_module_11 from "callbag-effect-ts/Source/async";
import * as Heartbeats from "./heartbeats.js";
import * as Identify from "./identify.js";
import * as InvalidSession from "./invalidSession.js";
import * as Utils from "./utils.js";
export const make = (shard) => tsplus_module_1.flatMap(({ token, gateway }) => tsplus_module_1.flatMap(socket => {
    const [emit, outgoing] = tsplus_module_11.asyncEmitter();
    return tsplus_module_1.flatMap(limiter => {
        const sendEffect = tsplus_module_7.run(tsplus_module_6.tap(() => limiter.maybeWait("shard.send", tsplus_module_10.minutes(1), 120))(outgoing), socket.sink);
        return tsplus_module_1.flatMap(raw => {
            const sendMessage = (a) => tsplus_module_1.sync(() => {
                emit.data(a);
            });
            return tsplus_module_1.flatMap(([latestReady, updateLatestReady]) => tsplus_module_1.map(([latestSequence, updateLatestSequence]) => {
                const maybeUpdateUrl = (p) => tsplus_module_8.match(() => tsplus_module_1.unit(), (a) => socket.setUrl(a.resume_gateway_url))(tsplus_module_8.map((p) => p.d)(tsplus_module_8.filter((p) => p.op === tsplus_module_4.Discord.GatewayOpcode.DISPATCH && p.t === "READY")(tsplus_module_8.some(p))));
                const updateRefs = tsplus_module_7.runDrain(tsplus_module_6.tap(maybeUpdateUrl)(tsplus_module_6.tap(updateLatestSequence)(tsplus_module_6.tap(updateLatestReady)(raw))));
                // heartbeats
                const heartbeatEffects = tsplus_module_3.forEach(sendMessage)(Heartbeats.fromRaw(raw, latestSequence));
                const dispatch = tsplus_module_5.filter((p) => p.op === tsplus_module_4.Discord.GatewayOpcode.DISPATCH)(raw);
                // identify
                const identifyEffects = tsplus_module_3.forEach(sendMessage)(Identify.fromRaw(raw, {
                    token,
                    shard,
                    intents: gateway.intents,
                    presence: gateway.presence,
                    latestSequence,
                    latestReady,
                }));
                // invalid session
                const invalidEffects = tsplus_module_3.forEach(sendMessage)(InvalidSession.fromRaw(raw, latestReady));
                return {
                    run: tsplus_module_1.zipPar(sendEffect)(tsplus_module_1.zipPar(invalidEffects)(tsplus_module_1.zipPar(identifyEffects)(tsplus_module_1.zipPar(heartbeatEffects)(updateRefs)))),
                    raw,
                    dispatch,
                    send: (p) => emit.data(p),
                    reconnect: () => emit.data(tsplus_module_2.WS.Reconnect),
                };
            })(Utils.latest((p) => tsplus_module_8.fromNullable(p.s))))(Utils.latest((p) => tsplus_module_8.map((p) => p.d)(tsplus_module_8.filter((p) => p.op === tsplus_module_4.Discord.GatewayOpcode.DISPATCH && p.t === "READY")(tsplus_module_8.some(p)))));
        })(tsplus_module_9.share(socket.source));
    })(tsplus_module_1.service(tsplus_module_4.RateLimitStore.RateLimiter));
})(tsplus_module_2.DWS.make()))(tsplus_module_1.service(tsplus_module_4.Config.DiscordConfig));
//# sourceMappingURL=index.js.map