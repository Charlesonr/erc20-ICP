import * as tsplus_module_1 from "callbag-effect-ts/Source/fromEffect";
import * as tsplus_module_2 from "callbag-effect-ts/Source/resource";
import * as tsplus_module_3 from "callbag-effect-ts/Source/map";
import * as tsplus_module_4 from "@fp-ts/data/Duration";
import * as tsplus_module_5 from "@fp-ts/data/Option";
import * as tsplus_module_6 from "callbag-effect-ts/Source/empty";
import * as tsplus_module_7 from "@effect/io/Effect";
import * as tsplus_module_8 from "callbag-effect-ts/Source/of";
import * as tsplus_module_9 from "dfx/common-gateway";
import * as tsplus_module_10 from "callbag-effect-ts/Source/tap";
import * as tsplus_module_11 from "callbag-effect-ts/Source/mapEffect";
import * as tsplus_module_12 from "callbag-effect-ts/Source/groupBy";
import * as tsplus_module_13 from "callbag-effect-ts/Source/chainPar";
import * as tsplus_module_14 from "dfx/common";
import * as tsplus_module_15 from "callbag-effect-ts/Source/drain";
import * as tsplus_module_16 from "callbag-effect-ts/Source/merge";
import * as tsplus_module_17 from "callbag-effect-ts/Source/unwrap";
import { millis } from "@fp-ts/data/Duration";
import { overridePull } from "callbag-effect-ts/Source";
import { ShardStore } from "../ShardStore/index.js";
const configs = (totalCount) => tsplus_module_7.map(store => {
    const claimId = (sharderCount) => tsplus_module_7.flatMap((a) => tsplus_module_5.match(() => tsplus_module_7.delay(tsplus_module_4.minutes(3))(tsplus_module_7.succeed([
        tsplus_module_5.some(sharderCount),
        tsplus_module_6.empty,
    ])), (id) => tsplus_module_7.succeed([
        tsplus_module_5.some(sharderCount + 1),
        tsplus_module_8.of(id),
    ]))(a))(store
        .claimId({
        totalCount,
        sharderCount,
    }));
    return tsplus_module_3.map((id) => ({
        id,
        totalCount,
    }))(tsplus_module_2.resource(0, (sharderCount) => tsplus_module_1.fromEffect(claimId(sharderCount))));
})(tsplus_module_7.service(ShardStore));
const spawnEffect = tsplus_module_7.map(({ gateway, config, configs, limiter }) => {
    const [source, pull] = overridePull(configs, gateway.session_start_limit.max_concurrency);
    return tsplus_module_10.tap(() => tsplus_module_7.sync(pull))(tsplus_module_13.chainPar(([shardConfig, key]) => tsplus_module_11.mapEffect((c) => tsplus_module_9.Shard.make([c.id, c.totalCount]))(tsplus_module_10.tap(() => limiter.maybeWait(`gateway.sharder.${key}`, millis(config.identifyRateLimit[0]), config.identifyRateLimit[1]))(shardConfig)))(tsplus_module_12.groupBy((c) => c.id % c.concurrency)(tsplus_module_3.map((config) => ({
        ...config,
        url: gateway.url,
        concurrency: gateway.session_start_limit.max_concurrency,
    }))(source))));
})(tsplus_module_7.bind("configs", ({ gateway, config }) => configs(config.shardCount ?? gateway.shards))(tsplus_module_7.structPar({
    gateway: tsplus_module_7.catchAll(() => tsplus_module_7.succeed({
        url: "wss://gateway.discord.gg/",
        shards: 1,
        session_start_limit: {
            total: 0,
            remaining: 0,
            reset_after: 0,
            max_concurrency: 1,
        },
    }))(tsplus_module_7.flatMap((r) => r.json)(tsplus_module_14.Rest.rest
        .getGatewayBot())),
    config: tsplus_module_14.Config.gateway,
    limiter: tsplus_module_7.service(tsplus_module_14.RateLimitStore.RateLimiter),
})));
export const spawn = tsplus_module_13.chainPar((shard) => tsplus_module_16.merge(tsplus_module_15.drain(tsplus_module_1.fromEffect(shard.run)))(tsplus_module_8.of(shard)))(tsplus_module_17.unwrap(spawnEffect));
//# sourceMappingURL=index.js.map