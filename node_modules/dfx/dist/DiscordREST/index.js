import * as tsplus_module_1 from "@effect/io/Effect";
import * as tsplus_module_2 from "dfx/common";
import * as tsplus_module_3 from "@fp-ts/data/Equal";
import * as tsplus_module_4 from "@fp-ts/data/Option";
import * as tsplus_module_5 from "@effect/io/Layer";
import { millis } from "@fp-ts/data/Duration";
import { rateLimitFromHeaders, routeFromConfig } from "./utils.js";
import Pkg from "../../package.json" assert { type: "json" };
const make = tsplus_module_1.flatMap(({ token, rest }) => tsplus_module_1.flatMap(log => tsplus_module_1.flatMap(store => tsplus_module_1.map(({ maybeWait }) => {
    const globalRateLimit = maybeWait("rest.global", rest.globalRateLimit.window, rest.globalRateLimit.limit);
    const requestRateLimit = (path, init) => (() => {
        const route = routeFromConfig(path, init);
        return tsplus_module_1.flatMap(maybeBucket => {
            const bucket = tsplus_module_4.getOrElse(() => ({
                key: `?.${tsplus_module_3.hash(route)}`,
                resetAfter: 5000,
                limit: 1,
            }))(maybeBucket);
            const resetAfter = millis(bucket.resetAfter);
            return tsplus_module_1.map(() => void 0)(maybeWait(`rest.bucket.${bucket.key}`, resetAfter, bucket.limit));
        })(store.getBucketForRoute(route));
    })();
    const updateBuckets = (path, init, response) => tsplus_module_1.ignore((() => {
        const route = routeFromConfig(path, init);
        return tsplus_module_1.flatMap(({ bucket, retryAfter, limit, remaining }) => {
            const effectsToRun = [store.putBucketRoute(route, bucket)];
            return tsplus_module_1.flatMap(hasBucket => {
                if (!hasBucket || limit - 1 === remaining) {
                    effectsToRun.push(store.putBucket({
                        key: bucket,
                        resetAfter: retryAfter.millis,
                        limit: !hasBucket && remaining > 0 ? remaining : limit,
                    }));
                }
                return tsplus_module_1.map(() => void 0)(tsplus_module_1.collectAllParDiscard(effectsToRun));
            })(store.hasBucket(bucket));
        })(tsplus_module_1.fromOption(rateLimitFromHeaders(response.headers)));
    })());
    const request = (path, init = {}) => tsplus_module_1.tap(({ response }) => updateBuckets(path, init, response))(tsplus_module_1.catchTag("StatusCodeError", (e) => e.code === 429
        ? tsplus_module_1.flatMap(() => tsplus_module_1.flatMap(() => request(path, init))(updateBuckets(path, init, e.response)))(log.debug("DiscordREST", "429", path)) : tsplus_module_1.fail(e))(tsplus_module_1.flatMap(() => tsplus_module_2.Http.requestWithJson(`${rest.baseUrl}${path}`, {
        ...init,
        headers: {
            ...(init?.headers ?? {}),
            Authorization: `Bot ${token}`,
            "User-Agent": `DiscordBot (https://github.com/tim-smart/dfx, ${Pkg.version})`,
        },
    }))(tsplus_module_1.tap(() => globalRateLimit)(requestRateLimit(path, init)))));
    return { request };
})(tsplus_module_1.service(tsplus_module_2.RateLimitStore.RateLimiter)))(tsplus_module_1.service(tsplus_module_2.RateLimitStore.RateLimitStore)))(tsplus_module_1.service(tsplus_module_2.Log.Log)))(tsplus_module_1.service(tsplus_module_2.Config.DiscordConfig));
export const DiscordREST = tsplus_module_2.Tag();
export const LiveDiscordREST = tsplus_module_5.fromEffect(DiscordREST)(make);
export const rest = tsplus_module_2.Discord.createRoutes(({ method, url, params, options = {} }) => tsplus_module_1.serviceWithEffect(DiscordREST)(({ request }) => {
    const hasBody = method !== "GET" && method !== "DELETE";
    let hasFormData = typeof options?.body?.append === "function";
    let body = undefined;
    const headers = {};
    if (hasBody && !hasFormData) {
        headers["content-type"] = "application/json";
    }
    const qs = new URLSearchParams();
    if (!hasBody) {
        Object.entries((params ?? {})).forEach(([key, value]) => {
            qs.append(key, value);
        });
    }
    else if (hasFormData) {
        body = options.body;
        if (params) {
            ;
            body.append("payload_json", JSON.stringify(params));
        }
    }
    else if (params) {
        body = JSON.stringify(params);
    }
    else {
        body = options.body;
    }
    return request(`${url}?${qs.toString()}`, {
        method,
        headers,
        body,
    });
}));
//# sourceMappingURL=index.js.map