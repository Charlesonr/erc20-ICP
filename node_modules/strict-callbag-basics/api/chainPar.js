import { buffer_ } from "./buffer.js";
import { createPipe } from "./createPipe.js";
import * as LB from "./_internal/lb.js";
/**
 * A semi-push stream.
 *
 * It eagerly loads items until the `concurrency` target is met.
 */
export const chainParP_ = (self, fab, concurrency = Infinity) => (_, sink) => {
    const lb = LB.make((a) => sink(1, a), (e, s) => {
        if (e && s) {
            sub.cancel();
        }
        sink(2, e);
    }, maybePullInner, maybePullInner);
    let sub;
    function maybePullInner() {
        if (sub && lb.size() < concurrency) {
            sub.pull();
        }
    }
    createPipe(self, sink, {
        onStart(s) {
            sub = s;
            maybePullInner();
        },
        onData(_, data) {
            const inner = fab(data);
            lb.add(inner);
            maybePullInner();
        },
        onEnd: lb.end,
        onRequest: lb.pull,
        onAbort() {
            lb.abort();
        },
    });
};
export const chainPar_ = (self, fab, concurrency, bufferSize = Infinity) => buffer_(chainParP_(self, fab, concurrency), bufferSize, true);
export const chainParP = (fab, concurrency) => (self) => chainParP_(self, fab, concurrency);
export const chainPar = (fab, concurrency, bufferSize) => (self) => chainPar_(self, fab, concurrency, bufferSize);
