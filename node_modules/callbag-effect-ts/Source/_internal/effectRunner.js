import * as Exit from "@effect/io/Exit";
import * as FiberId from "@effect/io/Fiber/Id";
export const make = (r, onFail, capacity = Infinity) => {
    let effects = [];
    let effectsOffset = 0;
    const waitingCount = () => effects.length - effectsOffset;
    const resetEffects = () => {
        effects = [];
        effectsOffset = 0;
    };
    let currentCancel = undefined;
    let aborted = false;
    const abort = (cleanup) => {
        if (aborted)
            return;
        resetEffects();
        if (currentCancel) {
            currentCancel(FiberId.none)(() => { });
        }
        if (cleanup) {
            runEffect(cleanup);
        }
        aborted = true;
    };
    const runEffect = (e, cb) => {
        if (aborted)
            return;
        if (!currentCancel && !effects.length) {
            runEffectImpl(e, cb);
        }
        else if (waitingCount() < capacity - 1) {
            effects.push(e);
        }
    };
    const runEffectImpl = (e, cb) => {
        currentCancel = r.unsafeRunWith(e, (exit) => {
            currentCancel = undefined;
            if (Exit.isSuccess(exit)) {
                cb?.(exit.value);
            }
            else if (!(exit.cause._tag === "Interrupt" && aborted)) {
                onFail(exit.cause);
            }
            runNextEffect();
        });
    };
    const runNextEffect = () => {
        if (effectsOffset >= effects.length) {
            resetEffects();
            return;
        }
        const next = effects[effectsOffset];
        effects[effectsOffset] = undefined;
        effectsOffset++;
        runEffectImpl(next);
    };
    return {
        runEffect,
        abort,
    };
};
//# sourceMappingURL=effectRunner.js.map